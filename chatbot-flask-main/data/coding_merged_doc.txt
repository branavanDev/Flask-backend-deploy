          Basic C Programming

ITSC 3181 Introduction to Computer Architecture
      https://passlab.github.io/ITSC3181/


      Department of Computer Science
                Yonghong Yan
              yyan7@uncc.edu
      https://passlab.github.io/yanyh/
           C Programming Basics: Outline
• A crash course in the basics of C
 –   Overview comparison of C and Java
 –   Good evening
 –   Preprocessor
 –   Command line arguments
 –   Arrays and structures
 –   Pointers and dynamic memory


• The K&R C book for lots more details
 – Tons of info on web
• https://passlab.github.io/ITSC3181/res
  ources/C_Programming.pdf
                                           2
      main Function to Enter Execution
#include <stdio.h>
int main(int argc, char* argv[])
{
  /* print a greeting */
  printf("Good evening!\n");
  return 0;
}


                       $ ./goodevening
                       Good evening!
                       $
                                         3
                Breaking down the code
• #include <stdio.h> è java import
 – Include the contents of the file stdio.h
   • Case sensitive – lower case only
 – No semicolon at the end of line

• int main(…)
 – The OS calls this function when the program starts running.

• printf(format_string, arg1, …)
 – Prints out a string, specified by the format string and the
   arguments.

                                                                 4
             Command Line Arguments
• int main(int argc, char* argv[])
• argc
 – Number of arguments (including program name)
• argv
 –   Array of char*s (that is, an array of ‘c’ strings)
 –   argv[0]: = program name
 –   argv[1]: = first argument
 –   …
 –   argv[argc-1]: last argument




                                                          5
Like Java, like C, and Lots of Other Languages
1. Operators same as Java è forming programming expressions and
     basic statement for calculations/operations
 – Arithmetic
     • i = i+1; i++; i--; i *= 2;
     • +, -, *, /, %,

 – Relational and Logical
     • <, >, <=, >=, ==, !=
     • &&, ||, &, |, !


2. Syntax same as in Java è structured program statement
 –   if ( ) { } else { }
 –   while ( ) { }
 –   do { } while ( );
 –   for(i=1; i <= 100; i++) { }
 –   switch ( ) {case 1: … }
 –   continue; break;

                                                            6
                           Data Types
• Simple data types
datatype     size (byte)        values
char         1              -128 to 127
short        2              -32,768 to 32,767
int          4              -2,147,483,648 to 2,147,483,647
long         4              -2,147,483,648 to 2,147,483,647
float        4              3.4E+/-38 (7 digits)
double           8              1.7E+/-308 (15 digits long)

• Complex data types
 – Array: int A[100];
 – struct ~= class

• Declare a variable: symbol and type. E.g. int a
 – Type indicate size
 – Symbol: A human-understandable name for a memory location
                                                              7
           Main Memory (DRAM) of a Computer
CPU or Processor
  Control Unit
     ALU
                                                 Input
                               Main Memory   I/OOutput
                                                 Processor   CPU is also called a chip.
  IR       PC


  MBR     MAR



                 Data Bus

                 Control Bus

                 Address Bus




                                                                                   8
                 Memory and Address
• Memory are accessed via the address of memory cells that store
  data
 – int a = A[i];
   • Read value from a memory location whose address is represented by
     A[i];
   • Write value to a memory location whose address is represented by a




                                                                   9
        Variables ç èMemory Locations

                                               int is a 4-byte data type.




• Variable (x) is symbolic representation of a memory location/address
• Two types of access to a variable/memory location: Read or write
 – = x: Right value, i.e. appears on the right side of =
   • read/load the content from the memory location
 – x =: Left value, i.e. appears on the left side of =
   • Write a value to the memory location
                                                                            10
           Memory layout and addresses
                                         Sizes of data types
                                         int: 4 bytes
                                         float: 4 bytes
                                         char: 1 byte
   int x = 5, y = 10;
                                         double: 8 bytes
   float f = 12.5, g = 9.8;
                                         long: 8 bytes
   char c = ‘c’, d = ‘d’;


       5           10          12.5             9. 8           c        d
4300        4304        4308             4312           4316
                                                            4317


                        Byte addresses                             11
                         Pointers
• Pointers are variables that hold an address in memory.
• That address points to another variable.




                                                           12
                    Using Pointers (1)

float f;           /* data variable */
float *f_addr;     /* pointer variable: store the memory
                    * address of a float variable */
           f               f_addr           any float
               ?               ?                ?
           4300               4304         any address

f_addr = &f;       /* & = operator to get the address */

           f               f_addr

               ?              4300
           4300               4304                         13
                Pointers made easy (2)

*f_addr = 3.2; /* indirection operator: assign the value
             3.2 to the memory cell at address f_addr */
         f              f_addr

          3.2              4300
         4300               4304
float g = *f_addr;/* indirection: read value at memory
                   address f_addr, g is now 3.2 */
f = 1.3;    /* but g is still 3.2 */
         f              f_addr

          1.3              4300
         4300               4304                         14
              A Variable from CA Point of View
•   int a;
•   float f;
•   int * ap;
•   float *fp
•   char * str;
•   char * argv[];
•   A variable
    – Name of the variable is the symbolic representation of the memory address for the first
      byte of the memory location allocated for the variable
    – Type: size of the memory for the variable
      • char: 1 byte, int/float/long: 4 bytes; double: 8 bytes
      • char *, int *, float *, double *, void *: 4 or 8 bytes depends on whether it is a 32 or 64-
        bit system
    – Variable reference == address reference
      • On the left of =: load the value of an address, type is used to determine how many bytes
        to load
      • On the right of =: store a value to the address, type is used to determine how many
        bytes to store
    – &x = address of x
    – *p = content at address p
                                                                                              15
C Variable and Pointer   & = address of
                         * = contents at




                                      16
C Pointer and Memory

                  & = address of
                  * = contents at




                                17
                          Arrays
• Adjacent memory locations storing the same type of data
 – Elements are packed in memory space
• int a[6]; means space for six integers
 – Each int is 4 bytes                       a[5]
                                             a[4]
                                             a[3]
                                             a[2]
                                             a[1]
                                             a[0]




• a is the symbol (variable) representing the array’s base
  address, which is the address of element a[0] as well.
 – 0x0C
                                                             18
Address of Array Elements
• int a[6];


• Offset of a[i]: stride (number of bytes) between a[0] and a[i]
  – i*sizeof(int)
• Byte address of a[i] (&a[i]): base + offset
                           &a[i]: (char*)a + i * sizeof(int)
  – E.g. &a[2]: 0x0C + 2 * 4 = 0x14
  – (char*)a is a cast of (int*) to (char*), to make sure compiler
    recognizes it as a byte address so it can add up i*sizeof(int)
  – In C, &a[i] is also a+i since C compiler is able to scale the
    pointer arithmetic with the size of the data type of the array
    • Thus &a[i]: a + i, this is pointer arithmetic, not regular arithmeti
• By itself, a is also the address of the first integer           19
  – *a and a[0] mean the same thing
Address of Array Elements
• int a[6];


• Offset of a[i] from a[j]: stride (number of bytes) from a[j] to
  a[i]
                      &a[i]: (char*)&a[j] + (i-j) * sizeof(int), or
  – (i-j)*sizeof(int)
                             &a[j] + i-j
  – Example, given &a[3] is 0x18, what is &a[5]
                 &a[5]: (char*)&a[3] + (5-3) * sizeof(int), or
                        &a[3] + 5-3
  – Example, given &a[4] is 0x1c, what is &a[2]
                 &a[2]: (char*)&a[4] + (2-4) * sizeof(int), or
                        &a[4] + 2-4                        20
21
                       sizeof Arrays
• int a[6];
 – sizeof(a)
  = 6 × sizeof(int)
  = 6 × 4 = 24 bytes

• char foo[80];
 – An array of 80 characters
 – sizeof(foo)
   = 80 × sizeof(char)
   = 80 × 1 = 80 bytes




                                       22
                      Multidimensional Arrays
•   Array declarations read right-to-left
•   int a[10][3][2];
•   “an array of ten arrays of three arrays of two ints”
•   In memory

          3            3                      3


                                    ...

      2   2   2   2    2   2              2   2   2


                               10
                                                      Seagram Building, Ludwig
                                                      Mies van der Rohe,1957
                                                                          23
        C Stores Array in Memory in Row Major
                                   8       6     5     4
         int A[3][4];              2       1     9     7
                                   3       6     4     2




                     Offset of A[1][2]
                                            Address of element A[1][2]:
                                           = (char*) A + offset (from A to A[1][2])
                                           = (char*) A + sizeof (int) * (1 * 4 + 2)
                                           = (char*) A + 4 * 6 = (char *)A + 24
Offset of A[i][j] from A[ of an array A[M][N]:
                                                                                24
i*N + j
   C Stores Array in Memory in Row Major
                         8       6       5    4
    int A[3][4];         2       1       9    7
                         3       6       4    2




             Offset of A[1][2] from A[0][1]

Given the address of A[0][1], find the address of element A[1][2]:
           = (char*) A[0][1] + offset (from A[0][1] to A[1][2])
           = (char*) A[0][1] + sizeof (int) * ((1-0) * 4 + 2-1)
           = (char*) A[0][1] + 4 * 5 = (char*) A[0][1] + 20     25
   C Stores Array in Memory in Row Major
                      8     6        5       4
    int A[3][4];      2     1        9       7
                      3     6        4       2




                                Offset of A[1][2] from A[2][1]

Given the address of A[2][1], find the address of element A[1][2]:
           = (char*) A[2][1] + offset (from A[2][1] to A[1][2])
           = (char*) A[2][1] + sizeof (int) * ((1-2) * 4 + 2-1)
           = (char*) A[2][1] + 4 * -3 = (char*) A[2][1] - 12    26
                          Structures
• Similar to Java class, but no methods
#include <stdio.h>

struct person {
  char*     name;
  int       age;
}; /* <== DO NOT FORGET the semicolon */
int main(int argc, char* argv[])
{
  struct person bovik;
  bovik.name = "Harry Bovik";
  bovik.age = 25;

    printf("%s is %d years old\n", bovik.name, bovik.age);
    return 0;
}                                                            27
        Address of Fields of Struct Object
• Similar to array that pack struct fields together
 – Complicated because of alignment
   • Char: 1 byte, int: 4 bytes, double: 8 bytes

 – 4-byte alignment




 – 8-byte alignment (one way)




                                                      28
Extend to Array of Structs and Struct of Arrays




                                           ……


                                            ……
                                              29
    Multidimensional Arrays the Java Way
• Use arrays of pointers for variable-sized multidimensional
  arrays
 – Java’s approach for multi-dimensional array
 – Need to allocate space for and initialize the arrays of pointers
int **a;
a[5][4] expands to *(*(a+5)+4)
           int **a

                                                    The value




                             int *       int

                                                                  30
                  If-else Statements
• C code:
  if (i==j) f = g+h;
  else f = g-h;

• Condition check i==j?
• Arithmetic operation: g+h, g-h




                                       31
                        Loop Statement
                                                i = 0;
for (i=0; i<100; i++) { … }
                                      False               True
                                              i < 100 ?
while (i<100) { …; i++; }                                        …
                                    Exit                     i ++
• Loop execution:
  –   Init condition
  –   Loop condition check
  –   True path (the loop body)
  –   Loop back
  –   False path (break the loop)



                                                                     32
               Loop Statement: for loop
                                                   i = 0;
• C code:
  for (i=0; i<100; i++) …
                                      False                 True
                                              i < 100 ?
                                                                   …
                                    Exit                       i ++
How many times does each each statement execute?

• i=0:
  – only executes once
• i<100:
  – execute 100 times
• i++:
  – execute 100 times
• …:
 – execute 100 times (if they don’t modify i)
                                                                       33
        Loop Statement: while loop (textbook 2.7)

• C code:
                                 False   (save[i]   True
int save[100];                           == k) ?

while (save[i] == k) i += 1;   Exit                    i += 1




How many times does each each statement execute?
• save[i] == k:
 – check every iteration
• i+1=1:
 – execute every iteration
• What is the problem of this code?
                                                            34
      Counting Operations of A C Program
                                  float sum(int N, float X[], float a) {
                                     int i;
                                     float result = 0.0;
                                     for (i = 0; i < N; ++i) {
                                        result += a * X[i];
                                     }
• N = 1000                           return result;
                                  }
• Arithmetic and logic operation:
 – i++, +, *: three operations per iteration è 3000
• Array reference
 – X[i]: one array reference per iteration è 1000
• Condition check (if-else, loop)
 – i < N: one check per iteration è 1000
                                                                           35
        Counting Operations of A C Program
                      int      N = 1000;
                      int      A[N][N], B[N][N], C[N][N]
                      int      i, j;
                      for      (i=0; i < N; i++) {
                              for(j=0; j < N; j++) {
                               A[i][j] += B[i][j] * C[N][N] * C[N][N];
                          }
                      }
• Arithmetic and logic operation:
  – j++, +, *, *: four operations per iteration of inner loop è 4M
  – i++: one operation per outer loop iteration è 1000
• Array reference
  – A[i][j], B[i][j], C[i][j], C[i][j], A[i][j]: 5 array reference per iteration of
    inner loop è 5M
• Condition check (if-else, loop)
  – j < N: one check per iteration of inner loop è 1M
  – i<N: one check per iteration of outer loop è 1000
                                                                                      36
          Counting  Operations
              int N = 1000, i;
                               of A C Program
                       int A[N], B[N], C[i]
                       for (i=0; i < N; i++) {
                          if (B[i] != 0) A[i] += B[i] * C[i] + C[i];
                          else A[i] += C[i]; //Else
                       }
• 40% of B[N] elements are NOT zeros
  –   if (B[i] != 0): executed for each iteration
  –   True: A[i] += B[i] * C[i] + C[i]; executed 40% of total iteration
  –   False: A[i] += C[i]; executed 60% of total iteration
• Arithmetic and logic operation:
  –   i++: one operation for each iteration è 1000
  –   True: +, *, +: three operations of 40% of total iterations è 3*1000 * 40% = 1200
  –   False: +: one operation of 60% of total iterations è 1*1000 * 60% = 600
  –   Thus in total: 2800
• Array reference
  –   If (B[i] …): one per iteration è 1000
  –   True: A[i], B[i], C[i], C[i], A[i]: 5 of 40% of total iterations è 5*1000*40% = 2000
  –   False: A[i], C[i], B[i]: 3 of 60% of total iterations è 3*1000*60% = 1800
  –   Thus total: 4800
• Condition check (if-else, loop)
  –   i<N: one check per iteration è 1000
  –   If (B[i] …): one check per iteration è 1000
  –   Total: 2000                                                                            37
End of Introduction of C Basics




                                  38
     Additional Topics for C Programming
• C Preprocessing
• Dynamic memory
• Function parameters
 – Pass by value
 – Pass a pointer




                                           39
               C Preprocessor
#define FIFTEEN_TWO_THIRTEEN \
  "The Class That Gives CMU Its Zip\n"

int main(int argc, char* argv[])
{
  printf(FIFTEEN_TWO_THIRTEEN);
  return 0;
}




                                         40
    After the preprocessor (gcc -E)

int main(int argc, char* argv)
{
  printf("The Class That Gives CMU Its Zip\n");
  return 0;
}




                                           41
         Conditional Compilation

#define CSCE212

int main(int argc, char* argv)
{
  #ifdef CSCE212
  printf("The Class That Gives CMU Its Zip\n");
  #else
  printf("Some other class\n");
  #endif
  return 0;
}

                                           42
    After the preprocessor (gcc –E)

int main(int argc, char* argv)
{
  printf("The Class That Gives CMU Its Zip\n");
  return 0;
}




                                           43
                   Dynamic Memory
• Java manages memory for you, C does not
 – C requires the programmer to explicitly allocate and deallocate
   memory
 – Unknown amounts of memory can be allocated dynamically
   during run-time with malloc() and deallocated using
   free()




                                                                44
                       Not like Java
• No new
• No garbage collection
• You ask for n bytes
 – Not a high-level request such as
   “I’d like an instance of class String”




                                            45
                            malloc
• Allocates memory in the heap
 – Lives between function invocations
   • Functional variables disappear after a function return

• Example
 – Allocate an integer
   • int* iptr =
      (int*) malloc(sizeof(int));
 – Allocate a structure
   • struct name* nameptr = (struct name*)
      malloc(sizeof(struct name));


                                                              46
                           free
• Deallocates memory in heap.
• Pass in a pointer that was returned by malloc.
• Example
 – int* iptr =
     (int*) malloc(sizeof(int));
   free(iptr);
• Caveat: don’t free the same memory block twice!




                                                    47
                  Function Parameters
• Function arguments are passed “by value”.

• What is “pass by value”?
 – The called function is given a copy of the arguments.
• What does this imply?

 – The called function can’t alter a variable in the caller function,
   but its private copy.

• Three examples


                                                                    48
             Example 1: swap_1
void swap_1(int a, int b)
{                             Q: Let x=3, y=4,
  int temp;
  temp = a;
                                 after
  a = b;                        swap_1(x,y);
  b = temp;                      x =? y=?
}

void call_swap_1( ) {
  int x = 3;
                                A1: x=4; y=3;
  int y = 4;
  swap_1(x, y);
                                A2: x=3; y=4;
  /* values of x and y ? */
}
                                             49
             Example 2: swap_2
void swap_2(int *a, int *b)
{                             Q: Let x=3, y=4,
  int temp;                      after
  temp = *a;                     swap_2(&x,&y);
  *a = *b;                        x =? y=?
  *b = temp;
}
                               A1: x=3; y=4;
void call_swap_2( ) {
  int x = 3;
                               A2: x=4; y=3;
  int y = 4;
  swap_1(&x, &y);
  /* values of x and y ? */
}
                                               50
   Example 3: scanf (read an input)


#include <stdio.h>     Q: Why using
                          pointers in scanf?
int main()
{                       A: We need to assign
  int x;                   the value to x.
  scanf(“%d\n”, &x);
  printf(“%d\n”, x);
}




                                           51


  Unit




  C++ PROGRAMMING BASICS

                                           Lesson Structure

2.0       Objective
2.1       Introduction
2.2       Basic C++ Program Construction
2.3       C++ Data Types
2.4       C++ Manipulators
2.5       C++ Arithmetic Operators
2.6       C++ Library Functions
2.7       Preprocessor Directives in C++
2.8       Summary
2.9       Questions
2.10 Suggested Readings



2.0 Objective

After going through this unit you will understand:

         Data Types and Manipulators in C++
         Different types of Arithmetic operators in C++
         Library functions in C++
         Structure of a C++ program
         Components of a basic C++ program
2.1 Introduction

Programs in C++ are simple and well structured. There are some basic components in every C++ program
that we write. There are some special lines called Preprocessor Directives that are interpreted even before the
compilation of the program begins. Programmers can give comments within their programs to make the
statements understandable to novice users. The Standard Library of C++ consists of classes and functions.
These classes and functions are written in the core language. They even form part of the C++ ISO Standard.
Data Types in C++ are used by users to declare variables. Primary Data Types in C++ are Integer, Character,
Boolean, Floating Point etc. C++ uses Datatype Modifiers to modify the length of data that a particular data
type can hold. Datatype Modifiers are used with the built-in data types. In C++, data can be manipulated
according to the choice of display of the programmer. To format the output, special operators called
Manipulators are used.

The rest of the unit is organized as follows. Section 2.2 describes the structure of a basic C++ program.
Sections 2.3 and 2.4 explain C++ Data Types and Manipulators respectively. Sections 2.5 and 2.6 explain
C++ Arithmetic operators and Library functions respectively. Section 2.7 explains the preprocessor directives.
Section 2.8 gives a brief overview of the unit. Section 2.9 contains some questions for the students and section
2.10 gives the references for the unit.


2.2 Basic C++ Program Construction

Let us start with a simple program that can help us to understand the fundamental components of a C++
program. The following program prints the text as shown in the Output below.



        1.       // First C++ Program
        2.       #include <iostream>
        3.
        4.       using namespace std;
        5.       int main ()
        6.       {
        7.       cout << "Hello World! ";
        8.       cout << " This is my first C++ Program ";
        9.       return 0;
        10.      }


OUTPUT: Hello world! This is my first C++ Program.

Let us analyze the program one statement at a time.

1st Line: // First C++ Program

The first statement in the program is just a comment inserted by the programmer within the program. A
comment line is indicated by two leading slash signs as shown here. Comments have no effect on the
behavior of the program. This is known as single line comment. Multi line comment is shown as below:
/* This is my first program.

I will learn how to write C++ program and how to compile the same*/

2nd Line: #include <iostream>

Lines that begin with hash signs (#) are called preprocessor directives. These special lines are interpreted
even before the program compilation starts. The preprocessor directive #include <iostream> informs the
preprocessor to include the header iostream, which is a part of the standard C++ code. The header iostream
permits the accomplishment of the standard input and output operations, for e.g., in this case it prints the
output on the computer screen.

3rd Line: A blank line.

There is no effect of blank lines on the program. It just makes the program easy to read.

4th Line: using namespace std;

Suppose the code that you are writing has the function abc() in it. Similarly, there is another library that has
the same function abc(). The compiler is not aware that which abc() function you are referring to in your
code.

A namespace solves this problem and it is used as an extra information to distinguish between similar
classes, functions, variables etc. that have the same name but are available in different libraries. Namespace
basically defines the scope.

In C++, namespaces are used to define a scope. They make it possible to group global classes, objects
and/or functions into a single group. Through using namespace std;, C++ compiler is instructed to use the
standard C++ library. If this instruction is not used, then each time you use a standard C++ function or
entity, you have to use std::.

Like without using namespace same program will be as below:
        1.       // First program in C++
        2.       #include <iostream>
        3.
        4.       int main ()
        5.       {
        6.       std::cout << "Hello World! ";
        7.       std::cout << " This is my first C++ Program ";
        8.       return 0;
        9.       }


5th Line: int main ()
This line initiates the declaration of a function. A function is nothing but a collection of statements that is
given a name. In this case the function is given the name “main”. The declaration of a function is preceded
by a type (int), followed by a name (main) and a pair of parentheses (()). Optionally parameters can be
included within the parentheses.

The main function is a special function that is called automatically. The code in any other function is
executed only if that function is called from the main function (directly or indirectly). For all C++ programs,
the execution begins with the main function. It does not matter where the main function is located in the
program.

6th and 10th Line: { and }
The body of a function is enclosed within an open brace ({) and a closing brace (}). It is defined within
these braces that what actually happens when the function is called. In the above program, the body of the
main function is enclosed within the open brace at line 6 and the closing brace at line 10.

7th Line: cout << "Hello World!";
8th Line: cout << " This is my first C++ Program ";
Lines 7 and 8 are C++ statements. Statements are executed in the exact order in which they appear inside
the body of a function.
The statements consist of three parts: The first part, i.e. cout, recognizes the standard character output device
(generally the computer screen). The second part, i.e. insertion operator (<<), specifies that anything that
follows the insertion operator is inserted into cout. The third part, i.e. a sentence within quotes (for e.g.
“Hello World!”) is the content that is to be inserted into the standard output.




                                            Figure 2.1: Usage of cout

The reader should notice that the statement ends with a semicolon (;). In fact, all the statements in C++
should end with a semicolon character. A common mistake by programmers is leaving the semicolon at the
end of statements.
9th Line: return 0;
The task of the return statement is to send a status report to the OS about the program execution. It informs
the OS whether the program has executed properly or not.
Program: print the given lines on computer screen.
   I am 18 years old.
   I am student of Polytechnic.
Solution:
        #include <iostream>
       using namespace std;
       int main(int argc, char *argv[])
       {
               int age;
               age=18;
               cout<<" I am "<<age<<" years old.\n";
               cout<<" I am student of Polytechnic.\n";
               return 0;
       }

Program: write first program using class

       #include <iostream>
       using namespace std;
       class Test         //class declaration start with keyword class and then name of the class
       {
               int i;                     //data variable
               public:
               void show()                //Member Function
               {
                          cout<<"Inside Member Function";
               }
       }; // end of Class
       int main()
       {
               Test obj;                   // Creating object of Abc class
               obj.show();                 // Use of class object to call member function
       }


Output:
       Inside Member Function
How to define a class in C++?
To define a class in C++, we use the keyword class, which is followed by the class name. The class body
is enclosed within the opening and closing curly brackets. The closing curly bracket is followed by a
semicolon.
        class ClassName
          {
          // data
          // functions
          };

How to create object in C++?
Syntax to define the object in main function.
        className cn; //cn is the object
This is very similar to declaration of variable in C / C++.
How to access data member and member function in C++?
The dot operator (.) is used to access the data members and member functions. For e.g.,
        obj2.func1();
The above statement will call the function func1() inside the Test class for object obj2.
To access the data member, the following statement is used:
        obj1.data1 = 7.3;
The reader should note that if he wants to access private members, then it can be done from within the class
only.


Program: usage of classes and objects in C++


        #include <iostream>
        using namespace std;
        class Sample
        {
              private:
                 int data_1;
                 float data_2;
              public:
                 void insertIntegerNumber(int d_1)
                 {
                          data_1 = d_1;
                          cout << "Number: " << data_1;
                 }
                float insertFloatingNumber()
                {
                         cout << "\nEnter data: ";
                         cin >> data_2;
                         return data_2;
                }
        };
        int main()
        {
                Sample obj1, obj2;
                float f;
                obj1.insertIntegerNumber(15);
                f = obj2.insertFloatingNumber();
                cout << "You entered " << f;
                return 0;
        }


Output:
        Number: 15
        Enter data: 23.3
        You entered 23.3

2.3 C++ Data Types

There are two types of C++ Data Types:
Primitive Data Types: Primitive Data Types are predefined or built-in data types that can be used by the
user directly for variable declaration. In C++, the following primitive data types are there:

       Character
       Floating Point
       Integer
       Valueless or Void
       Boolean
       Double Floating Point
       Wide Character

Abstract or user defined data type: Abstract data types are defined by the user himself.
The definitions of the primitive data types have been give below:


       Character: The data type Character stores characters. The keyword that is used for this data type
        is char. Each Character generally occupies a memory space of 1 byte. The range is from -128 to
        127 or 0 to 255.
       Floating Point: The data type Floating Point stores decimal values or single precision floating point
        values. The keyword that is used for this data type is float. Each Float variable generally occupies
        a memory space of 4 bytes.
       Integer: The keyword that is used for this data type is int. Each Integer generally occupies a
        memory space of 4 bytes. The range is from -2147483648 to 2147483647.
           Void: This data type means that there is no value. This data type is used for the functions that do
            not return any value.
           Boolean: The data type Boolean stores logical values or boolean. The two values that can be stored
            in a boolean variable is either true or false. The Keyword that is used for data type boolean is bool.
           Double Floating Point: The data type Double Floating Point stores decimal values or double
            precision floating point values. The keyword that is used for this data type is double. Each Double
            variable generally occupies a memory space of 8 bytes.
           Wide Character: The data type Wide character is also a character data type. But it generally
            occupies 2 or 4 bytes of memory space. The keyword that is used for this data type is wchar_t.

Datatype Modifiers: In C++, Datatype Modifiers are used along with Primitive data types to alter the data
length that can be held by a specific data type. Following are the Datatype modifiers in C++:

             Short
             Long
             Signed
             Unsigned

Table 1.1 shows the altered size and range of built-in data types when used in combination with datatype
modifiers.


Table 1.1: Size and Range of Data Types

               Data Type                      Size (In Bytes)                         Range


  Int                                     4                       -2,147,483,648 to 2,147,483,647


  unsigned short int                      2                       0 to 65,535


  short int                               2                       -32,768 to 32,767


  unsigned int                            4                       0 to 4,294,967,295


  unsigned long int                       4                       0 to 4,294,967,295


  long int                                4                       -2,147,483,648 to 2,147,483,647


  unsigned long long int                  8                       0 to 18,446,744,073,709,551,615
  long long int                         8                        -(2^63) to (2^63)-1


  Float                                 4


  double                                8


  long double                           12


  unsigned char                         1                        0 to 255


  signed char                           1                        -128 to 127


  wchar_t                               2 or 4                   1 wide character




2.4 C++ Manipulators

C++ offers several input/output manipulators for formatting, commonly used manipulators are given below:
endl
endl manipulator is used to Terminate a line and flushes the buffer.
To produce a newline while writing the output in C++, you can either use ‘\n’ or ‘std::endl’. But each one
has a varying outcome.
         std::endl inserts a new line and flushes the output buffer.
         '\n' only inserts a new line but does not flush the output buffer.
When writing debugging messages that need to be seen instantly, you should not use ‘\n’ but should use
std::endl so that the flush is forced to happen instantly.
The following example shows how both the versions are used. However, the flushing is not visible in this
example.
Program: manipulators in C++
          #include <iostream.h>
          int main()
          {
                  cout<<"USING '\\n' ...\n";
                  cout<<"Line 1 \nLine 2 \nLine 3 \n";
                    cout<<"USING end ..."<< endl;
                    cout<< "Line 1" << endl << "Line 2" << endl << "Line 3" << endl;
                    return 0;
          }
Output:




setw() and setfill()
setw manipulator sets the width of the filed assigned for the output.

The field width specifies what should be the minimum number of characters that can be written in the output
representation. If the field width is more than the standard width of the representation, then setfill() is used
to pad the representation with fill characters.

Syntax:
  setw([number_of_characters]);
  setfill([character]);

Program: usage of setw() and setfill()
          #include <iostream.h>
          #include <iomanip.h>
          int main()
          {
             cout<<"USING setw() ..............\n";
              cout<< setw(10) <<11<<"\n";
              cout<< setw(10) <<2222<<"\n";
              cout<< setw(10) <<33333<<"\n";
              cout<< setw(10) <<4<<"\n";


              cout<<"USING setw() & setfill() [type- I]...\n";
              cout<< setfill('0');
              cout<< setw(10) <<11<<"\n";
              cout<< setw(10) <<2222<<"\n";
              cout<< setw(10) <<33333<<"\n";
              cout<< setw(10) <<4<<"\n";


              cout<<"USING setw() & setfill() [type-II]...\n";
              cout<< setfill('-')<< setw(10) <<11<<"\n";
              cout<< setfill('*')<< setw(10) <<2222<<"\n";
              cout<< setfill('@')<< setw(10) <<33333<<"\n";
              cout<< setfill('#')<< setw(10) <<4<<"\n";
              return 0;
          }


Output:




setf() and setprecision()
setprecision manipulator sets the total number of digits to be displayed, when floating point numbers are
printed.
Syntax:
  setprecision([number_of_digits]);
  cout<<setprecision(5)<<1234.537;
  // output will be: 1234.5
On the default floating point notation, the precision field specifies the total number of digits that should be
displayed as output, including the digits before the decimal point and the digits after the decimal point.
In scientific and fixed notations, the number of digits before the decimal point is of no importance. In this
case, the precision field specifies the number of digits after the decimal point. If needed, zeros can be added
at the trail.

Syntax:
          setf([flag_value],[field bitmask]);


                            Table 1.2: Field bitmask and Flag values

                                   field bitmask                    flag values

                               adjustfield            left, right or internal

                               basefield              dec, oct or hex

                               floatfield             scientific or fixed



Program: usage of setf() and setprecision()
          #include <iostream.h>
          #include <iomanip.h>
          int main()
          {
                  cout<<"USING fixed .......................\n";
                   cout.setf(ios::floatfield,ios::fixed);
                   cout<< setprecision(5)<<1234.537<< endl;


                   cout<<"USING scientific ..................\n";
                   cout.setf(ios::floatfield,ios::scientific);
                   cout<< setprecision(5)<<1234.537<< endl;
                   return 0;
          }

Output:
2.5 C++ Arithmetic Operators

Table 1.3 shows the arithmetic operators that are used in C++. Suppose that A variable holds the value 10
and B variable holds the value 20.

Table 1.3: Arithmetic Operators in C++


 Operator       Description                                               Example


 /              Dividing numerator by the denominator                     B / A gives 2


 ++             Increment operator- increments the value of the integer   A++ gives 11
                by one


 *              Multiplication of both the operands                       A * B gives 200


 +              Addition of two operands                                  A + B gives 30


 -              Subtracting second operand from first operand             A - B gives -10


 %              Modulus operator - remainder of integer division          B % A gives 0


 --             Decrement operator- decrements the value of the integer   A-- gives 9
                by one




2.6 C++ Library Functions

The Standard Library of C++ is composed of two parts.

         The Standard Function Library – This library comprises of the basic stand-alone functions that
          do not form the part of any class. The function library has been inherited from C language.

         The Object Oriented Class Library − This library consists of classes and their associated
          functions.
The Standard Library of C++ also includes all the standard libraries of C, with some modifications and
additions to support type safety.

The Standard Function Library

The standard function library can be categorized into the following types:

       I/O - functions for standard I/O
       Mathematical
       Time, date, and localization
       Wide-character functions
       String and character handling
       Dynamic allocation
       Miscellaneous


The Object Oriented Class Library

The Object Oriented Class Library of C++ specifies a set of classes that allow a number of activities like
numeric processing and including strings, I/O. Following are the constituents of the Library:

       Exception Handling Classes
       The STL Container Classes
       The Localization library
       The STL Algorithms
       The Standard C++ I/O Classes
       The STL Function Objects
       The String Class
       The STL Iterators
       The Numeric Classes
       The STL Allocators
       Miscellaneous Support Library


2.7 Preprocessor Directives in C++

Preprocessors are programs that process our source code before compilation. In between writing a program
and executing a program, a good number of steps are involved. Before understanding Preprocessors, we
should look at the following steps first.
.




                                          Figure 2.2: Usage of Preprocessors


The reader can see the steps involved in Figure 2.2 above. Initially, the programmer writes the source code
which is then stored in the file program.c. Next, the file is processed by Preprocessors which leads to the
generation of an expanded source code file named program. The compiler then compiles the expanded file
leading to the generation of an object code file named program.obj. In the end, the object code file is linked
to the object code of the library functions by the linker. This again leads to the generation of an executable
file program.exe.

Preprocessors provide preprocessor directives that instruct the compiler to preprocess the source code even
before the compilation starts. All preprocessor directives in C++ start with the hash symbol (#). If there is
a ‘#’ symbol before a statement in C++, then it means that the statement is a preprocessor directive.
Preprocessor directives can be placed at any location in the program. Some examples of preprocessor
directives are #define, #include, etc.

Basic types of preprocessor directives are:

    1.     File Inclusion
    2.     Conditional Compilation
    3.     Macros
    4.     Other directives

1. File Inclusion: File Inclusion instructs the compiler to include a file in the program. The user can include
two types of files in his program.

         a. Header File or Standard files: The Header Files consist of the definition of pre-defined functions
            such as scanf() and printf() etc. For these functions to work, the header files must be included in
            the program. Different header files contain the declarations for different functions.

             Syntax:
                    #include< file-name >

          where file-name is the name of the file that is to be included. The opening bracket (<) and the
          closing bracket (>) instruct the compiler to search the file in the standard directory.

    b. User defined files: It is a good practice to divide a large program into smaller files and include
       them as and when required. Such files are user defined files and can be included in the following
       way.

          Syntax:

                    #include"filename"

2. Conditional Compilation: Conditional Compilation allows us to compile a particular part of the program
or skip compilation of a particular part of the program on the basis of some conditions. Two preprocessing
commands i.e. ‘ifdef’ and ‘endif’ can help in accomplishing this.

Syntax:

          ifdef macro-name
                  line1;
                  line2;
                  line3;
                  .
                  .
                  .
                  lineN;
          endif

If the macro named ‘macro-name’ is defined, then the lines are normally executed. Otherwise, the compiler
skips these lines.

3. Macros: A Macro is a piece of code in a program that is given a name. When the compiler sees this name
in the program, it replaces the name with the actual piece of code. In C++, to define a macro, the directive
‘#define’ is used. We now look at the following program to understand macro definition.


Program: usage of macro
          #include<iostream>
          // definition of the macro
          #define LIMIT 6
          int main()
        {
                  for(int k=0; k < LIMIT; k++)
                  {
                          std::cout<<k<<"\n";
                  }
                  return 0;
        }


Output:
                  0
                  1
                  2
                  3
                  4
                  5

4. Other directives: Other than the above discussed directives we have two more directives that are used,
but not so frequently.

    a. #pragma Directive: This is a directive that is used for special purpose, i.e. to turn some features
       on or off. Such directives vary from one compiler to another i.e. they are specific to the compiler
       being used.

    b. #undef Directive: This directive undefines an existing macro.

        Syntax:
                  #undef LIMIT

        This statement undefines LIMIT which is an existing macro. After the execution of the statement
        “#ifdef LIMIT” will evaluate to false.

2.8 Summary

All C++ programs consist of well-defined components. Comments which are inserted in between statements
do not affect the behavior of the program. However, they can help in understanding the meaning of the
statements. Preprocessor directives are special lines that are interpreted even before the compilation of the
program begins. The Standard Library of C++ consists of classes and functions. These classes and functions
are written in the core language. They even form part of the C++ ISO Standard. The main function is a special
function that is called automatically. The code in any other function is executed only if that function is
called from the main function (directly or indirectly). For all C++ programs, the execution begins with the
main function. It does not matter where the main function is located in the program. To define a class in
C++, we use the keyword class, which is followed by the class name. Data members and member functions
can be accessed by using a dot operator (.). Data Types in C++ can be divided into two types: Primitive
Data Types and Abstract Data Types. Primitive Data Types are predefined data types or built-in data types
used directly by the users for variable declaration. Abstract Data Types are defined by the user himself. In
C++, Manipulators are used to format the output. The output can be designed to match the user’s choice of
display


2.9 Questions

1. Write a simple C++ program that takes the user’s name and age as input and prints it on the screen.
2. What do you mean by Preprocessor Directives?
3. What is the purpose of C++ Standard Library?
4. Why is the main function called the Starting function?
5. Give an example to show how data members and member functions are accessed in C++.
6. Briefly explain the Primary Data Types in C++.
7. Explain the following C++ Manipulators - setfill() and setprecision().
8. Describe the different types of Arithmetic Operators in C++.
9. What are Datatype Modifiers? Explain their usage.
10. Give an example to show how Objects are created in C++.

2.10 Suggested Readings

1. Lafore, Robert. Object-oriented programming in C++. Pearson Education, 1997.
2. https://www.tutorialspoint.com/cplusplus/cpp_standard_library.htm
3. https://www.geeksforgeeks.org/c-data-types/


Java

About the Tutorial
Java is a high-level programming language originally developed by Sun Microsystems and
released in 1995. Java runs on a variety of platforms, such as Windows, Mac OS, and the
various versions of UNIX. This tutorial gives a complete understanding of Java.
This reference will take you through simple and practical approaches while learning Java
Programming language.

Audience
This tutorial has been prepared for the beginners to help them understand the basic to
advanced concepts related to Java Programming language.

Prerequisites
Before you start practicing various types of examples given in this reference, we assume
that you are already aware about computer programs and computer programming
languages.

Execute Java Online
For most of the examples given in this tutorial, you will find a ‘Try it’ option, which you
can use to execute your Java programs at the spot and enjoy your learning.
Try following the example using the ‘Try it’ option available at the top right corner of the
following sample code box −
public class MyFirstJavaProgram {

public static void main(String []args) {
System.out.println("Hello World");
}
}

i

Java

Table of Contents
About the Tutorial ............................................................................................................................................ i
Audience ........................................................................................................................................................... i
Prerequisites ..................................................................................................................................................... i
Execute Java Online .......................................................................................................................................... i
Table of Contents ............................................................................................................................................ ii

JAVA – BASICS ............................................................................................................................. 1
1.

Java – Overview ........................................................................................................................................ 2
History of Java ................................................................................................................................................. 3
Tools You Will Need ......................................................................................................................................... 3
Try It Option .................................................................................................................................................... 4
What is Next? .................................................................................................................................................. 4

2.

Java - Environment Setup ......................................................................................................................... 5
Try it Option Online ......................................................................................................................................... 5
Local Environment Setup ................................................................................................................................. 5
Popular Java Editors ........................................................................................................................................ 6
What is Next? .................................................................................................................................................. 6

3.

Java – Basic Syntax .................................................................................................................................... 7
First Java Program ........................................................................................................................................... 7
Basic Syntax ..................................................................................................................................................... 8
Java Identifiers ................................................................................................................................................. 9
Java Modifiers.................................................................................................................................................. 9
Java Variables .................................................................................................................................................. 9
Java Arrays ....................................................................................................................................................... 9
Java Enums .................................................................................................................................................... 10
Java Keywords ............................................................................................................................................... 10
Comments in Java .......................................................................................................................................... 11
Using Blank Lines ........................................................................................................................................... 12
Inheritance .................................................................................................................................................... 12
Interfaces ....................................................................................................................................................... 12
What is Next? ................................................................................................................................................ 12

4.

Java – Objects & Classes.......................................................................................................................... 13
Objects in Java ............................................................................................................................................... 13
Classes in Java ................................................................................................................................................ 14
Constructors .................................................................................................................................................. 14
How to Use Singleton Class? ......................................................................................................................... 15
Creating an Object ......................................................................................................................................... 17
Accessing Instance Variables and Methods................................................................................................... 18
Source File Declaration Rules ........................................................................................................................ 20
Java Package .................................................................................................................................................. 20
Import Statements ........................................................................................................................................ 21
A Simple Case Study ...................................................................................................................................... 21
What is Next? ................................................................................................................................................ 23
ii

Java

5.

Java – Basic Datatypes ............................................................................................................................ 24
Primitive Datatypes ....................................................................................................................................... 24
Reference Datatypes ..................................................................................................................................... 26
Java Literals ................................................................................................................................................... 26
What is Next? ................................................................................................................................................ 28

6.

Java – Variable Types .............................................................................................................................. 29
Local Variables ............................................................................................................................................... 29
Instance Variables ......................................................................................................................................... 31
Class/static Variables ..................................................................................................................................... 33
What is Next? ................................................................................................................................................ 34

7.

Java – Modifier Types ............................................................................................................................. 35
Java Access Modifiers .................................................................................................................................... 35
Java Non-Access Modifiers ............................................................................................................................ 38
The Static Modifier ........................................................................................................................................ 38
The Final Modifier ......................................................................................................................................... 39
The Abstract Modifier.................................................................................................................................... 41
Access Control Modifiers ............................................................................................................................... 43
Non-Access Modifiers .................................................................................................................................... 44
What is Next? ................................................................................................................................................ 44

8.

Java – Basic Operators ............................................................................................................................ 45
The Arithmetic Operators .............................................................................................................................. 45
The Relational Operators............................................................................................................................... 47
The Bitwise Operators ................................................................................................................................... 49
The Logical Operators .................................................................................................................................... 52
The Assignment Operators ............................................................................................................................ 53
Miscellaneous Operators............................................................................................................................... 57
Precedence of Java Operators ....................................................................................................................... 59
What is Next? ................................................................................................................................................ 59

9.

Java – Loop Control ................................................................................................................................. 60
While Loop in Java ......................................................................................................................................... 61
for Loop in Java .............................................................................................................................................. 62
Do While Loop in Java ................................................................................................................................... 65
Loop Control Statements ............................................................................................................................... 67
Break Statement in Java ................................................................................................................................ 67
Continue Statement in Java ........................................................................................................................... 69
Enhanced for loop in Java .............................................................................................................................. 70
What is Next? ................................................................................................................................................ 71

10. Java – Decision Making ........................................................................................................................... 72
If Statement in Java ....................................................................................................................................... 73
If-else Statement in Java................................................................................................................................ 74
The if...else if...else Statement ...................................................................................................................... 76
Nested if Statement in Java ........................................................................................................................... 77
Switch Statement in Java ............................................................................................................................... 78
The ? : Operator: ........................................................................................................................................... 80
What is Next? ................................................................................................................................................ 81
iii

Java

11. Java – Numbers Class .............................................................................................................................. 82
Number Methods .......................................................................................................................................... 83
Java XXXValue Method .................................................................................................................................. 86
Java – compareTo() Method .......................................................................................................................... 87
Java – equals() Method ................................................................................................................................. 88
Java – valueOf() Method ............................................................................................................................... 89
Java – toString() Method ............................................................................................................................... 91
Java – parseInt() Method ............................................................................................................................... 92
Java – abs() Method ...................................................................................................................................... 93
Java – ceil() Method ...................................................................................................................................... 94
Java – floor() Method .................................................................................................................................... 95
Java – rint() Method ...................................................................................................................................... 96
Java – round() Method .................................................................................................................................. 97
Java – min() Method ...................................................................................................................................... 98
Java – max() Method ..................................................................................................................................... 99
Java – exp() Method .................................................................................................................................... 100
Java – log() Method ..................................................................................................................................... 101
Java – pow() Method ................................................................................................................................... 102
Java – sqrt() Method.................................................................................................................................... 103
Java – sin() Method ..................................................................................................................................... 104
Java – cos() Method ..................................................................................................................................... 105
Java – tan() Method ..................................................................................................................................... 106
Java – asin() Method ................................................................................................................................... 107
Java – acos() Method ................................................................................................................................... 108
Java – atan() Method ................................................................................................................................... 109
Java – atan2() Method ................................................................................................................................. 110
Java – toDegrees() Method ......................................................................................................................... 111
Java – toRadians() Method .......................................................................................................................... 112
Java – random() Method ............................................................................................................................. 113
What is Next? .............................................................................................................................................. 114
12. Java – Character Class ........................................................................................................................... 115
Escape Sequences........................................................................................................................................ 115
Character Methods ...................................................................................................................................... 117
Java – isLetter() Method .............................................................................................................................. 117
Java – isDigit() Method ................................................................................................................................ 118
Java – isWhitespace() Method .................................................................................................................... 119
Java – isUpperCase() Method ...................................................................................................................... 120
Java – isLowerCase() Method ...................................................................................................................... 121
Java – toUpperCase() Method ..................................................................................................................... 122
Java – toLowerCase() Method ..................................................................................................................... 123
Java – toString() Method ............................................................................................................................. 124
What is Next? .............................................................................................................................................. 125
13. Java – Strings Class ................................................................................................................................ 126
Creating Strings ........................................................................................................................................... 126
Java – String Buffer & String Builder Classes ............................................................................................... 126
StringBuffer Methods .................................................................................................................................. 127
Java – String Buffer append() Method ........................................................................................................ 128
Java – String Buffer reverse() Method ......................................................................................................... 129
iv

Java

Java – String Buffer delete() Method .......................................................................................................... 130
Java – String Buffer insert() Method ........................................................................................................... 131
Java – String Buffer replace() Method ......................................................................................................... 132
String Length................................................................................................................................................ 135
Concatenating Strings .................................................................................................................................. 136
Creating Format Strings ............................................................................................................................... 136
String Methods ............................................................................................................................................ 137
Java – String chartAt() Method .................................................................................................................... 142
Java – String compareTo(Object o) Method ................................................................................................ 143
Java – String compareTo(String anotherString) Method ............................................................................. 144
Java – String compareToIgnoreCase() Method ........................................................................................... 145
Java – String concat() Method ..................................................................................................................... 146
Java – String contentEquals() Method ......................................................................................................... 147
Java – String copyValueOf(char[] data) Method ......................................................................................... 148
Java – String copyValueOf(char[] data, int offset, int count) Method......................................................... 149
Java – String endsWith() Method ................................................................................................................ 150
Java – String equals() Method ..................................................................................................................... 151
Java – String equalsIgnoreCase() Method ................................................................................................... 152
Java – String getBytes(String charsetName) Method .................................................................................. 154
Java – String getBytes() Method .................................................................................................................. 155
Java – String getChars() Method ................................................................................................................. 156
Java – String hashCode() Method ................................................................................................................ 157
Java – String indexOf(int ch) Method .......................................................................................................... 158
Java – String indexOf(int ch, int fromIndex) Method .................................................................................. 159
Java – String indexOf(String str) Method .................................................................................................... 160
Java – String indexOf(String str, int fromIndex) Method ............................................................................. 161
Java – String Intern() Method ...................................................................................................................... 162
Java – String lastIndexOf(int ch) Method .................................................................................................... 163
Java – String lastIndexOf(int ch, int fromIndex) Method ............................................................................ 164
Java – String lastIndexOf(String str) Method ............................................................................................... 165
Java – String lastIndexOf(String str, int fromIndex) Method ....................................................................... 166
Java – String length() Method ..................................................................................................................... 167
Java – String matches() Method .................................................................................................................. 168
Java – String regionMatches() Method ....................................................................................................... 169
Java – String regionMatches() Method ....................................................................................................... 171
Java – String replace() Method .................................................................................................................... 173
Java – String replaceAll() Method................................................................................................................ 174
Java – String replaceFirst() Method ............................................................................................................. 175
Java – String split() Method ......................................................................................................................... 176
Java – String split() Method ......................................................................................................................... 178
Java – String startsWith() Method ............................................................................................................... 180
Java – String startsWith() Method ............................................................................................................... 181
Java – String subsequence() Method .......................................................................................................... 182
Java – String substring() Method ................................................................................................................. 183
Java – String substring() Method ................................................................................................................. 184
Java – String toCharArray() Method ............................................................................................................ 186
Java – String toLowerCase() Method ........................................................................................................... 187
Java – String toLowerCase() Method ........................................................................................................... 188
Java – String toString() Method ................................................................................................................... 189
Java – String toUpperCase() Method ........................................................................................................... 189
v

Java

Java – String toUpperCase() Method ........................................................................................................... 190
Java – String trim() Method ......................................................................................................................... 191
Java – String valueOf() Method ................................................................................................................... 192
14. Java – Arrays ......................................................................................................................................... 196
Declaring Array Variables ............................................................................................................................ 196
Creating Arrays ............................................................................................................................................ 196
Processing Arrays ........................................................................................................................................ 198
The foreach Loops ....................................................................................................................................... 199
Passing Arrays to Methods .......................................................................................................................... 199
Returning an Array from a Method ............................................................................................................. 200
The Arrays Class ........................................................................................................................................... 200
15. Java – Date & Time ............................................................................................................................... 202
Getting Current Date & Time....................................................................................................................... 203
Date Comparison ......................................................................................................................................... 204
Simple DateFormat Format Codes .............................................................................................................. 205
Date and Time Conversion Characters ........................................................................................................ 208
Parsing Strings into Dates ............................................................................................................................ 209
Sleeping for a While .................................................................................................................................... 210
Measuring Elapsed Time ............................................................................................................................. 211
GregorianCalendar Class ............................................................................................................................. 212
16. Java – Regular Expressions .................................................................................................................... 218
Capturing Groups ........................................................................................................................................ 218
Regular Expression Syntax ........................................................................................................................... 220
Methods of the Matcher Class .................................................................................................................... 223
17. Java – Methods ..................................................................................................................................... 230
Creating Method ......................................................................................................................................... 230
Method Calling ............................................................................................................................................ 231
The void Keyword ........................................................................................................................................ 232
Passing Parameters by Value ....................................................................................................................... 233
Method Overloading ................................................................................................................................... 235
Using Command-Line Arguments ................................................................................................................ 236
The Constructors ......................................................................................................................................... 237
Parameterized Constructor ......................................................................................................................... 238
The this keyword ......................................................................................................................................... 239
Variable Arguments(var-args) ..................................................................................................................... 242
The finalize( ) Method ................................................................................................................................. 243
18. Java – Files and I/O ............................................................................................................................... 244
Stream ......................................................................................................................................................... 244
Standard Streams ........................................................................................................................................ 247
Reading and Writing Files ............................................................................................................................ 248
ByteArrayInputStream ................................................................................................................................. 250
DataInputStream ......................................................................................................................................... 253
FileOutputStream ........................................................................................................................................ 255
ByteArrayOutputStream .............................................................................................................................. 256
DataOutputStream ...................................................................................................................................... 259
File Navigation and I/O ................................................................................................................................ 261
vi

Java

File Class ...................................................................................................................................................... 262
Directories in Java........................................................................................................................................ 272
Listing Directories ........................................................................................................................................ 273
19. Java – Exceptions .................................................................................................................................. 275
Exception Hierarchy..................................................................................................................................... 276
Built-in Exceptions ....................................................................................................................................... 277
Exceptions Methods .................................................................................................................................... 279
Catching Exceptions..................................................................................................................................... 280
Multiple Catch Blocks .................................................................................................................................. 281
Catching Multiple Type of Exceptions ......................................................................................................... 282
The Throws/Throw Keywords ..................................................................................................................... 282
The Finally Block .......................................................................................................................................... 283
The try-with-resources ................................................................................................................................ 285
User-defined Exceptions .............................................................................................................................. 287
Common Exceptions .................................................................................................................................... 290
20. Java – Inner Classes ............................................................................................................................... 291
Nested Classes ............................................................................................................................................. 291
Inner Classes (Non-static Nested Classes) ................................................................................................... 292
Accessing the Private Members .................................................................................................................. 293
Method-local Inner Class ............................................................................................................................. 294
Anonymous Inner Class ............................................................................................................................... 295
Anonymous Inner Class as Argument .......................................................................................................... 296
Static Nested Class....................................................................................................................................... 297

JAVA - OBJECT ORIENTED ........................................................................................................ 299
21. Java – Inheritance ................................................................................................................................. 300
extends Keyword ......................................................................................................................................... 300
Sample Code ................................................................................................................................................ 300
The super keyword ...................................................................................................................................... 302
Invoking Superclass Constructor ................................................................................................................. 305
IS-A Relationship .......................................................................................................................................... 306
The instanceof Keyword .............................................................................................................................. 308
HAS-A relationship....................................................................................................................................... 309
Types of Inheritance .................................................................................................................................... 309
22. Java – Overriding .................................................................................................................................. 311
Rules for Method Overriding ....................................................................................................................... 313
Using the super Keyword ............................................................................................................................ 314
23. Java – Polymorphism ............................................................................................................................ 315
Virtual Methods ........................................................................................................................................... 316
24. Java – Abstraction ................................................................................................................................. 320
Abstract Class .............................................................................................................................................. 320
Inheriting the Abstract Class........................................................................................................................ 323
Abstract Methods ........................................................................................................................................ 324
vii

Java

25. Java – Encapsulation ............................................................................................................................. 326
Benefits of Encapsulation ............................................................................................................................ 328
26. Java – Interfaces ................................................................................................................................... 329
Declaring Interfaces ..................................................................................................................................... 330
Implementing Interfaces ............................................................................................................................. 330
Extending Interfaces .................................................................................................................................... 332
Extending Multiple Interfaces ..................................................................................................................... 333
Tagging Interfaces ....................................................................................................................................... 333
27. Java – Packages ..................................................................................................................................... 334
Creating a Package ...................................................................................................................................... 334
The import Keyword .................................................................................................................................... 336
The Directory Structure of Packages ........................................................................................................... 337
Set CLASSPATH System Variable.................................................................................................................. 339

JAVA – ADVANCED .................................................................................................................. 340
28. Java – Data Structures........................................................................................................................... 341
The Enumeration ......................................................................................................................................... 341
The BitSet .................................................................................................................................................... 343
The Vector ................................................................................................................................................... 348
The Stack ..................................................................................................................................................... 355
The Dictionary ............................................................................................................................................. 358
The Hashtable .............................................................................................................................................. 362
The Properties ............................................................................................................................................. 366
29. Java – Collections Framework ............................................................................................................... 370
The Collection Interfaces ............................................................................................................................. 371
The Collection Interface .............................................................................................................................. 372
The List Interface ......................................................................................................................................... 375
The Set Interface ......................................................................................................................................... 378
The SortedSet Interface ............................................................................................................................... 380
The Map Interface ....................................................................................................................................... 382
The Map.Entry Interface.............................................................................................................................. 384
The SortedMap Interface ............................................................................................................................ 386
The Enumeration Interface.......................................................................................................................... 388
The Collection Classes ................................................................................................................................. 389
The LinkedList Class ..................................................................................................................................... 391
The ArrayList Class ....................................................................................................................................... 395
The HashSet Class ........................................................................................................................................ 399
The LinkedHashSet Class ............................................................................................................................. 402
The TreeSet Class ......................................................................................................................................... 403
The HashMap Class ...................................................................................................................................... 406
The TreeMap Class ...................................................................................................................................... 409
The WeakHashMap Class ............................................................................................................................ 412
The LinkedHashMap Class ........................................................................................................................... 415
The IdentityHashMap Class ......................................................................................................................... 418
The Vector Class .......................................................................................................................................... 422
The Stack Class ............................................................................................................................................ 428
viii

Java

The Dictionary Class .................................................................................................................................... 430
The Map Interface ....................................................................................................................................... 431
The Hashtable Class ..................................................................................................................................... 433
The Properties Class .................................................................................................................................... 437
The BitSet Class ........................................................................................................................................... 440
The Collection Algorithms ........................................................................................................................... 445
How to Use an Iterator ? ............................................................................................................................. 450
How to Use a Comparator ? ........................................................................................................................ 454
Summary ..................................................................................................................................................... 456
30. Java – Generics ..................................................................................................................................... 457
Generic Methods ......................................................................................................................................... 457
Bounded Type Parameters .......................................................................................................................... 459
Generic Classes ............................................................................................................................................ 460
31. Java – Serialization ................................................................................................................................ 462
Serializing an Object .................................................................................................................................... 463
Deserializing an Object ................................................................................................................................ 464
32. Java – Networking................................................................................................................................. 466
URL Processing ............................................................................................................................................ 466
URL Class Methods ...................................................................................................................................... 467
URLConnections Class Methods .................................................................................................................. 470
Socket Programming ................................................................................................................................... 473
ServerSocket Class Methods ....................................................................................................................... 474
Socket Class Methods .................................................................................................................................. 475
InetAddress Class Methods ......................................................................................................................... 477
Socket Client Example ................................................................................................................................. 477
Socket Server Example ................................................................................................................................ 479
33. Java – Sending E-mail ............................................................................................................................ 481
Send a Simple E-mail ................................................................................................................................... 481
Send an HTML E-mail ................................................................................................................................... 483
Send Attachment in E-mail .......................................................................................................................... 485
User Authentication Part ............................................................................................................................. 487
34. Java – Multithreading ........................................................................................................................... 488
Life Cycle of a Thread .................................................................................................................................. 488
Thread Priorities .......................................................................................................................................... 489
Create a Thread by Implementing a Runnable Interface ............................................................................ 489
Create a Thread by Extending a Thread Class ............................................................................................. 491
Thread Methods .......................................................................................................................................... 494
Major Java Multithreading Concepts .......................................................................................................... 499
Thread Synchronization ............................................................................................................................... 499
Interthread Communication ........................................................................................................................ 504
Thread Deadlock .......................................................................................................................................... 507
Thread Control............................................................................................................................................. 510
35. Java – Applet Basics .............................................................................................................................. 515
Life Cycle of an Applet ................................................................................................................................. 515
A "Hello, World" Applet ............................................................................................................................... 516
ix

Java

The Applet Class .......................................................................................................................................... 516
Invoking an Applet ....................................................................................................................................... 517
HTML <applet> Tag ...................................................................................................................................... 517
HTML Attribute Reference .......................................................................................................................... 519
HTML Events Reference .............................................................................................................................. 521
Getting Applet Parameters .......................................................................................................................... 526
Specifying Applet Parameters ..................................................................................................................... 527
Application Conversion to Applets .............................................................................................................. 527
Event Handling ............................................................................................................................................ 528
Displaying Images ........................................................................................................................................ 530
Playing Audio ............................................................................................................................................... 532
36. Java – Documentation Comments ......................................................................................................... 534
What is Javadoc? ......................................................................................................................................... 534
The javadoc Tags ......................................................................................................................................... 535

x

Java – Basics

1. Java – Overview

Java

Java programming language was originally developed by Sun Microsystems which was
initiated by James Gosling and released in 1995 as core component of Sun Microsystems'
Java platform (Java 1.0 [J2SE]).
The latest release of the Java Standard Edition is Java SE 8. With the advancement of Java
and its widespread popularity, multiple configurations were built to suit various types of
platforms. For example: J2EE for Enterprise Applications, J2ME for Mobile Applications.
The new J2 versions were renamed as Java SE, Java EE, and Java ME respectively. Java
is guaranteed to be Write Once, Run Anywhere.
Java is:


Object Oriented: In Java, everything is an Object. Java can be easily extended
since it is based on the Object model.



Platform Independent: Unlike many other programming languages including C
and C++, when Java is compiled, it is not compiled into platform specific machine,
rather into platform independent byte code. This byte code is distributed over the
web and interpreted by the Virtual Machine (JVM) on whichever platform it is being
run on.



Simple: Java is designed to be easy to learn. If you understand the basic concept
of OOP Java, it would be easy to master.



Secure: With Java's secure feature it enables to develop virus-free, tamper-free
systems. Authentication techniques are based on public-key encryption.



Architecture-neutral: Java compiler generates an architecture-neutral object
file format, which makes the compiled code executable on many processors, with
the presence of Java runtime system.



Portable: Being architecture-neutral and having no implementation dependent
aspects of the specification makes Java portable. Compiler in Java is written in
ANSI C with a clean portability boundary, which is a POSIX subset.



Robust: Java makes an effort to eliminate error prone situations by emphasizing
mainly on compile time error checking and runtime checking.



Multithreaded: With Java's multithreaded feature it is possible to write programs
that can perform many tasks simultaneously. This design feature allows the
developers to construct interactive applications that can run smoothly.



Interpreted: Java byte code is translated on the fly to native machine
instructions and is not stored anywhere. The development process is more rapid
and analytical since the linking is an incremental and light-weight process.



High Performance: With the use of Just-In-Time compilers, Java enables high
performance.
2

Java



Distributed: Java is designed for the distributed environment of the internet.



Dynamic: Java is considered to be more dynamic than C or C++ since it is
designed to adapt to an evolving environment. Java programs can carry extensive
amount of run-time information that can be used to verify and resolve accesses
to objects on run-time.

History of Java
James Gosling initiated Java language project in June 1991 for use in one of his many settop box projects. The language, initially called ‘Oak’ after an oak tree that stood outside
Gosling's office, also went by the name ‘Green’ and ended up later being renamed as Java,
from a list of random words.
Sun released the first public implementation as Java 1.0 in 1995. It promised Write Once,
Run Anywhere (WORA), providing no-cost run-times on popular platforms.
On 13 November, 2006, Sun released much of Java as free and open source software
under the terms of the GNU General Public License (GPL).
On 8 May, 2007, Sun finished the process, making all of Java's core code free and opensource, aside from a small portion of code to which Sun did not hold the copyright.

Tools You Will Need
For performing the examples discussed in this tutorial, you will need a Pentium 200-MHz
computer with a minimum of 64 MB of RAM (128 MB of RAM recommended).
You will also need the following softwares:


Linux 7.1 or Windows xp/7/8 operating system



Java JDK 8



Microsoft Notepad or any other text editor

This tutorial will provide the necessary skills to create GUI, networking, and web
applications using Java.

3

Java

Try It Option
We have provided you with an option to compile and execute available code online. Just
click the Try it button avaiable at the top-right corner of the code window to compile and
execute the available code. There are certain examples which cannot be executed online,
so we have skipped those examples.
public class MyFirstJavaProgram {

public static void main(String []args) {
System.out.println("Hello World");
}
}
There may be a case that you do not see the result of the compiled/executed code. In
such case, you can re-try to compile and execute the code using execute button available
in the compilation pop-up window.

What is Next?
The next chapter will guide you to how you can obtain Java and its documentation. Finally,
it instructs you on how to install Java and prepare an environment to develop Java
applications.

4

2. Java - Environment Setup

Java

In this chapter, we will discuss on the different aspects of setting up a congenial
environment for Java.

Try it Option Online
You really do not need to set up your own environment to start learning Java programming
language. Reason is very simple, we already have Java Programming environment setup
online, so that you can compile and execute all the available examples online at the same
time when you are doing your theory work. This gives you confidence in what you are
reading and to check the result with different options. Feel free to modify any example
and execute it online.
Try the following example using Try it option available at the top right corner of the
following sample code box:
public class MyFirstJavaProgram {

public static void main(String []args) {
System.out.println("Hello World");
}
}
For most of the examples given in this tutorial, you will find the Try it option, which you
can use to execute your programs and enjoy your learning.

Local Environment Setup
If you are still willing to set up your environment for Java programming language, then
this section guides you on how to download and set up Java on your machine. Following
are the steps to set up the environment.
Java SE is freely available from the link Download Java. You can download a version based
on your operating system.
Follow the instructions to download Java and run the .exe to install Java on your machine.
Once you installed Java on your machine, you will need to set environment variables to
point to correct installation directories:

Setting Up the Path for Windows
Assuming you have installed Java in c:\Program Files\java\jdk directory:


Right-click on 'My Computer' and select 'Properties'.



Click the 'Environment variables' button under the 'Advanced' tab.
5

Java



Now, alter the 'Path' variable so that it also contains the path to the Java
executable. Example, if the path is currently set to 'C:\WINDOWS\SYSTEM32', then
change
your
path
to
read
'C:\WINDOWS\SYSTEM32;c:\Program
Files\java\jdk\bin'.

Setting Up the Path for Linux, UNIX, Solaris, FreeBSD
Environment variable PATH should be set to point to where the Java binaries have been
installed. Refer to your shell documentation, if you have trouble doing this.
Example, if you use bash as your shell, then you would add the following line to the end
of your '.bashrc: export PATH=/path/to/java:$PATH'

Popular Java Editors
To write your Java programs, you will need a text editor. There are even more
sophisticated IDEs available in the market. But for now, you can consider one of the
following:


Notepad: On Windows machine, you can use any simple text editor like Notepad
(Recommended for this tutorial), TextPad.



Netbeans: A Java IDE that is open-source and free, which can be downloaded
from http://www.netbeans.org/index.html.



Eclipse: A Java IDE developed by the eclipse open-source community and can be
downloaded from http://www.eclipse.org/.

What is Next?
Next chapter will teach you how to write and run your first Java program and some of the
important basic syntaxes in Java needed for developing applications.

6

3. Java – Basic Syntax

Java

When we consider a Java program, it can be defined as a collection of objects that
communicate via invoking each other's methods. Let us now briefly look into what do class,
object, methods, and instance variables mean.


Object - Objects have states and behaviors. Example: A dog has states - color,
name, breed as well as behavior such as wagging their tail, barking, eating. An
object is an instance of a class.



Class - A class can be defined as a template/blueprint that describes the
behavior/state that the object of its type supports.



Methods - A method is basically a behavior. A class can contain many methods.
It is in methods where the logics are written, data is manipulated and all the
actions are executed.



Instance Variables - Each object has its unique set of instance variables. An
object's state is created by the values assigned to these instance variables.

First Java Program
Let us look at a simple code that will print the words Hello World.
public class MyFirstJavaProgram {

/* This is my first java program.
* This will print 'Hello World' as the output
*/

public static void main(String []args) {
System.out.println("Hello World"); // prints Hello World
}
}
Let's look at how to save the file, compile, and run the program. Please follow the
subsequent steps:


Open notepad and add the code as above.



Save the file as: MyFirstJavaProgram.java.



Open a command prompt window and go to the directory where you saved the
class. Assume it's C:\.

7

Java


Type 'javac MyFirstJavaProgram.java' and press enter to compile your code. If
there are no errors in your code, the command prompt will take you to the next
line (Assumption : The path variable is set).



Now, type ' java MyFirstJavaProgram ' to run your program.



You will be able to see ' Hello World ' printed on the window.

C:\> javac MyFirstJavaProgram.java
C:\> java MyFirstJavaProgram
Hello World

Basic Syntax
About Java programs, it is very important to keep in mind the following points.


Case
Sensitivity
- Java
is
case
sensitive,
which
identifier Helloand hello would have different meaning in Java.

means



Class Names - For all class names the first letter should be in Upper Case.
If several words are used to form a name of the class, each inner word's first letter
should be in Upper Case.
Example: class MyFirstJavaClass



Method Names - All method names should start with a Lower Case letter.
If several words are used to form the name of the method, then each inner word's
first letter should be in Upper Case.
Example: public void myMethodName()



Program File Name - Name of the program file should exactly match the class
name.
When saving the file, you should save it using the class name (Remember Java is
case sensitive) and append '.java' to the end of the name (if the file name and the
class
name
do
not
match,
your
program
will
not
compile).
Example: Assume 'MyFirstJavaProgram' is the class name. Then the file should
be saved as 'MyFirstJavaProgram.java'



public static void main(String args[]) - Java program processing starts from
the main() method which is a mandatory part of every Java program.

8

Java

Java Identifiers
All Java components require names. Names used for classes, variables, and methods are
called identifiers.
In Java, there are several points to remember about identifiers. They are as follows:


All identifiers should begin with a letter (A to Z or a to z), currency character ($)
or an underscore (_).



After the first character, identifiers can have any combination of characters.



A key word cannot be used as an identifier.



Most importantly, identifiers are case sensitive.



Examples of legal identifiers: age, $salary, _value, __1_value.



Examples of illegal identifiers: 123abc, -salary.

Java Modifiers
Like other languages, it is possible to modify classes, methods, etc., by using modifiers.
There are two categories of modifiers:


Access Modifiers: default, public , protected, private



Non-access Modifiers: final, abstract, strictfp

We will be looking into more details about modifiers in the next section.

Java Variables
Following are the types of variables in Java:


Local Variables



Class Variables (Static Variables)



Instance Variables (Non-static Variables)

Java Arrays
Arrays are objects that store multiple variables of the same type. However, an array itself
is an object on the heap. We will look into how to declare, construct, and initialize in the
upcoming chapters.

9

Java

Java Enums
Enums were introduced in Java 5.0. Enums restrict a variable to have one of only a few
predefined values. The values in this enumerated list are called enums.
With the use of enums it is possible to reduce the number of bugs in your code.
For example, if we consider an application for a fresh juice shop, it would be possible to
restrict the glass size to small, medium, and large. This would make sure that it would not
allow anyone to order any size other than small, medium, or large.

Example
class FreshJuice {

enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }
FreshJuiceSize size;
}

public class FreshJuiceTest {

public static void main(String args[]){
FreshJuice juice = new FreshJuice();
juice.size = FreshJuice.FreshJuiceSize.MEDIUM ;
System.out.println("Size: " + juice.size);
}
}

The above example will produce the following result:
Size: MEDIUM
Note: Enums can be declared as their own or inside a class. Methods, variables,
constructors can be defined inside enums as well.

Java Keywords
The following list shows the reserved words in Java. These reserved words may not be
used as constant or variable or any other identifier names.
abstract

assert

boolean

break

byte

case

catch

char

10

Java
class

const

continue

default

do

double

else

enum

extends

final

finally

float

for

goto

if

implements

import

instanceof

int

interface

long

native

new

package

private

protected

public

return

short

static

strictfp

super

switch

synchronized

this

throw

throws

transient

try

void

volatile

while

Comments in Java
Java supports single-line and multi-line comments very similar to C and C++. All
characters available inside any comment are ignored by Java compiler.
public class MyFirstJavaProgram{

/* This is my first java program.
* This will print 'Hello World' as the output
* This is an example of multi-line comments.
*/

public static void main(String []args){
// This is an example of single line comment
/* This is also an example of single line comment. */
System.out.println("Hello World");
}
}

11

Java

Using Blank Lines
A line containing only white space, possibly with a comment, is known as a blank line, and
Java totally ignores it.

Inheritance
In Java, classes can be derived from classes. Basically, if you need to create a new class
and here is already a class that has some of the code you require, then it is possible to
derive your new class from the already existing code.
This concept allows you to reuse the fields and methods of the existing class without having
to rewrite the code in a new class. In this scenario, the existing class is called the
superclass and the derived class is called the subclass.

Interfaces
In Java language, an interface can be defined as a contract between objects on how to
communicate with each other. Interfaces play a vital role when it comes to the concept of
inheritance.
An interface defines the methods, a deriving class (subclass) should use. But the
implementation of the methods is totally up to the subclass.

What is Next?
The next section explains about Objects and classes in Java programming. At the end of
the session, you will be able to get a clear picture as to what are objects and what are
classes in Java.

12

4. Java – Objects & Classes

Java

Java is an Object-Oriented Language. As a language that has the Object-Oriented feature,
Java supports the following fundamental concepts:


Polymorphism



Inheritance



Encapsulation



Abstraction



Classes



Objects



Instance



Method



Message Parsing

In this chapter, we will look into the concepts - Classes and Objects.


Object - Objects have states and behaviors. Example: A dog has states - color,
name, breed as well as behaviors – wagging the tail, barking, eating. An object is
an instance of a class.



Class - A class can be defined as a template/blueprint that describes the
behavior/state that the object of its type support.

Objects in Java
Let us now look deep into what are objects. If we consider the real-world, we can find
many objects around us, cars, dogs, humans, etc. All these objects have a state and a
behavior.
If we consider a dog, then its state is - name, breed, color, and the behavior is - barking,
wagging the tail, running.
If you compare the software object with a real-world object, they have very similar
characteristics.
Software objects also have a state and a behavior. A software object's state is stored in
fields and behavior is shown via methods.
So in software development, methods operate on the internal state of an object and the
object-to-object communication is done via methods.

13

Java

Classes in Java
A class is a blueprint from which individual objects are created.
Following is a sample of a class.
public class Dog{
String breed;
int ageC
String color;

void barking(){
}

void hungry(){
}

void sleeping(){
}
}
A class can contain any of the following variable types.


Local variables: Variables defined inside methods, constructors or blocks are
called local variables. The variable will be declared and initialized within the
method and the variable will be destroyed when the method has completed.



Instance variables: Instance variables are variables within a class but outside
any method. These variables are initialized when the class is instantiated. Instance
variables can be accessed from inside any method, constructor or blocks of that
particular class.



Class variables: Class variables are variables declared within a class, outside any
method, with the static keyword.

A class can have any number of methods to access the value of various kinds of methods.
In the above example, barking(), hungry() and sleeping() are methods.
Following are some of the important topics that need to be discussed when looking into
classes of the Java Language.

Constructors
When discussing about classes, one of the most important sub topic would be constructors.
Every class has a constructor. If we do not explicitly write a constructor for a class, the
Java compiler builds a default constructor for that class.

14

Java
Each time a new object is created, at least one constructor will be invoked. The main rule
of constructors is that they should have the same name as the class. A class can have
more than one constructor.
Following is an example of a constructor:
public class Puppy{
public Puppy(){
}

public Puppy(String name){
// This constructor has one parameter, name.
}
}
Java also supports Singleton Classes where you would be able to create only one instance
of a class.
Note: We have two different types of constructors. We are going to discuss constructors
in detail in the subsequent chapters.

How to Use Singleton Class?
The Singleton's purpose is to control object creation, limiting the number of objects to only
one. Since there is only one Singleton instance, any instance fields of a Singleton will occur
only once per class, just like static fields. Singletons often control access to resources,
such as database connections or sockets.
For example, if you have a license for only one connection for your database or your JDBC
driver has trouble with multithreading, the Singleton makes sure that only one connection
is made or that only one thread can access the connection at a time.

15

Java

Implementing Singletons
Example 1
The easiest implementation consists of a private constructor and a field to hold its result,
and a static accessor method with a name like getInstance().
The private field can be assigned from within a static initializer block or, more simply,
using an initializer. The getInstance( ) method (which must be public) then simply returns
this instance −
// File Name: Singleton.java
public class Singleton {

private static Singleton singleton = new Singleton( );

/* A private Constructor prevents any other
* class from instantiating.
*/
private Singleton(){ }

/* Static 'instance' method */
public static Singleton getInstance( ) {
return singleton;
}
/* Other methods protected by singleton-ness */
protected static void demoMethod( ) {
System.out.println("demoMethod for singleton");
}
}
Here is the main program file, where we will create a singleton object:
// File Name: SingletonDemo.java
public class SingletonDemo {
public static void main(String[] args) {
Singleton tmp = Singleton.getInstance( );
tmp.demoMethod( );
}
}

16

Java
This will produce the following result −
demoMethod for singleton

Example 2
Following implementation shows a classic Singleton design pattern:
public class ClassicSingleton {

private static ClassicSingleton instance = null;
private ClassicSingleton() {
// Exists only to defeat instantiation.
}
public static ClassicSingleton getInstance() {
if(instance == null) {
instance = new ClassicSingleton();
}
return instance;
} }
The ClassicSingleton class maintains a static reference to the lone singleton instance and
returns that reference from the static getInstance() method.
Here, ClassicSingleton class employs a technique known as lazy instantiation to create the
singleton; as a result, the singleton instance is not created until the getInstance() method
is called for the first time. This technique ensures that singleton instances are created only
when needed.

Creating an Object
As mentioned previously, a class provides the blueprints for objects. So basically, an object
is created from a class. In Java, the new keyword is used to create new objects.
There are three steps when creating an object from a class:


Declaration: A variable declaration with a variable name with an object type.



Instantiation: The 'new' keyword is used to create the object.



Initialization: The 'new' keyword is followed by a call to a constructor. This call
initializes the new object.

17

Java
Following is an example of creating an object:
public class Puppy{

public Puppy(String name){
// This constructor has one parameter, name.
System.out.println("Passed Name is :" + name );
}

public static void main(String []args){
// Following statement would create an object myPuppy
Puppy myPuppy = new Puppy( "tommy" );
}
}
If we compile and run the above program, then it will produce the following result:
Passed Name is :tommy

Accessing Instance Variables and Methods
Instance variables and methods are accessed via created objects. To access an instance
variable, following is the fully qualified path:
/* First create an object */
ObjectReference = new Constructor();

/* Now call a variable as follows */
ObjectReference.variableName;

/* Now you can call a class method as follows */
ObjectReference.MethodName();

18

Java

Example
This example explains how to access instance variables and methods of a class.
public class Puppy{

int puppyAge;

public Puppy(String name){
// This constructor has one parameter, name.
System.out.println("Name chosen is :" + name );
}

public void setAge( int age ){
puppyAge = age;
}

public int getAge( ){
System.out.println("Puppy's age is :" + puppyAge );
return puppyAge;
}

public static void main(String []args){
/* Object creation */
Puppy myPuppy = new Puppy( "tommy" );

/* Call class method to set puppy's age */
myPuppy.setAge( 2 );

/* Call another class method to get puppy's age */
myPuppy.getAge( );

/* You can access instance variable as follows as well */
System.out.println("Variable Value :" + myPuppy.puppyAge );
}
}

19

Java
If we compile and run the above program, then it will produce the following result:
Name chosen is :tommy
Puppy's age is :2
Variable Value :2

Source File Declaration Rules
As the last part of this section, let's now look into the source file declaration rules. These
rules are essential when declaring classes, import statements and package statements in
a source file.


There can be only one public class per source file.



A source file can have multiple non-public classes.



The public class name should be the name of the source file as well which should
be appended by .java at the end. For example: the class name is public class
Employee{} then the source file should be as Employee.java.



If the class is defined inside a package, then the package statement should be the
first statement in the source file.



If import statements are present, then they must be written between the package
statement and the class declaration. If there are no package statements, then the
import statement should be the first line in the source file.



Import and package statements will imply to all the classes present in the source
file. It is not possible to declare different import and/or package statements to
different classes in the source file.

Classes have several access levels and there are different types of classes; abstract
classes, final classes, etc. We will be explaining about all these in the access modifiers
chapter.
Apart from the above mentioned types of classes, Java also has some special classes called
Inner classes and Anonymous classes.

20

Java
End of ebook preview
If you liked what you saw…
Buy it from our store @ https://store.tutorialspoint.com

21



Dictionaries store connections between pieces of
information. Each item in a dictionary is a key-value pair.

List comprehensions
squares = [x**2 for x in range(1, 11)]

Slicing a list

alien = {'color': 'green', 'points': 5}

finishers = ['sam', 'bob', 'ada', 'bea']
first_two = finishers[:2]
Variables are used to store values. A string is a series of
characters, surrounded by single or double quotes.

Hello world

msg = "Hello world!"
print(msg)

Concatenation (combining strings)
first_name = 'albert'
last_name = 'einstein'
full_name = first_name + ' ' + last_name
print(full_name)

copy_of_bikes = bikes[:]

Make a list
bikes = ['trek', 'redline', 'giant']

Looping through all key-value pairs
Tuples are similar to lists, but the items in a tuple can't be
modified.

Making a tuple
dimensions = (1920, 1080)

If statements are used to test for particular conditions and
respond appropriately.

equals
not equal
greater than
or equal to
less than
or equal to

x
x
x
x
x
x

== 42
!= 42
> 42
>= 42
< 42
<= 42

Get the first item in a list

Conditional test with lists

first_bike = bikes[0]

'trek' in bikes
'surly' not in bikes

Get the last item in a list
last_bike = bikes[-1]

Looping through a list
for bike in bikes:
print(bike)

Adding items to a list
bikes = []
bikes.append('trek')
bikes.append('redline')
bikes.append('giant')

Making numerical lists
squares = []
for x in range(1, 11):
squares.append(x**2)

Adding a new key-value pair
alien['x_position'] = 0

Conditional tests
A list stores a series of items in a particular order. You
access items using an index, or within a loop.

Accessing a value
print("The alien's color is " + alien['color'])

Copying a list

print("Hello world!")

Hello world with a variable

A simple dictionary

Assigning boolean values
game_active = True
can_edit = False

A simple if test
if age >= 18:
print("You can vote!")

fav_numbers = {'eric': 17, 'ever': 4}
for name, number in fav_numbers.items():
print(name + ' loves ' + str(number))

Looping through all keys
fav_numbers = {'eric': 17, 'ever': 4}
for name in fav_numbers.keys():
print(name + ' loves a number')

Looping through all the values
fav_numbers = {'eric': 17, 'ever': 4}
for number in fav_numbers.values():
print(str(number) + ' is a favorite')

Your programs can prompt the user for input. All input is
stored as a string.

Prompting for a value
name = input("What's your name? ")
print("Hello, " + name + "!")

Prompting for numerical input
age = input("How old are you? ")
age = int(age)
pi = input("What's the value of pi? ")
pi = float(pi)

If-elif-else statements
if age < 4:
ticket_price = 0
elif age < 18:
ticket_price = 10
else:
ticket_price = 15

Covers Python 3 and Python 2

A while loop repeats a block of code as long as a certain
condition is true.

A simple while loop
current_value = 1
while current_value <= 5:
print(current_value)
current_value += 1

Letting the user choose when to quit
msg = ''
while msg != 'quit':
msg = input("What's your message? ")
print(msg)

Functions are named blocks of code, designed to do one
specific job. Information passed to a function is called an
argument, and information received by a function is called a
parameter.

A simple function
def greet_user():
"""Display a simple greeting."""
print("Hello!")
greet_user()

Passing an argument
def greet_user(username):
"""Display a personalized greeting."""
print("Hello, " + username + "!")

A class defines the behavior of an object and the kind of
information an object can store. The information in a class
is stored in attributes, and functions that belong to a class
are called methods. A child class inherits the attributes and
methods from its parent class.

Creating a dog class
class Dog():
"""Represent a dog."""
def __init__(self, name):
"""Initialize dog object."""
self.name = name
def sit(self):
"""Simulate sitting."""
print(self.name + " is sitting.")
my_dog = Dog('Peso')
print(my_dog.name + " is a great dog!")
my_dog.sit()

def make_pizza(topping='bacon'):
"""Make a single-topping pizza."""
print("Have a " + topping + " pizza!")
make_pizza()
make_pizza('pepperoni')

Returning a value
def add_numbers(x, y):
"""Add two numbers and return the sum."""
return x + y
sum = add_numbers(3, 5)
print(sum)

Reading a file and storing its lines
filename = 'siddhartha.txt'
with open(filename) as file_object:
lines = file_object.readlines()
for line in lines:
print(line)

Writing to a file
filename = 'journal.txt'
with open(filename, 'w') as file_object:
file_object.write("I love programming.")

Appending to a file
filename = 'journal.txt'
with open(filename, 'a') as file_object:
file_object.write("\nI love making games.")

Inheritance
class SARDog(Dog):
"""Represent a search dog."""
def __init__(self, name):
"""Initialize the sardog."""
super().__init__(name)
def search(self):
"""Simulate searching."""
print(self.name + " is searching.")

greet_user('jesse')

Default values for parameters

Your programs can read from files and write to files. Files
are opened in read mode ('r') by default, but can also be
opened in write mode ('w') and append mode ('a').

my_dog = SARDog('Willie')
print(my_dog.name + " is a search dog.")
my_dog.sit()
my_dog.search()

If you had infinite programming skills, what would you
build?

As you're learning to program, it's helpful to think
about the real-world projects you'd like to create. It's
a good habit to keep an "ideas" notebook that you
can refer to whenever you want to start a new project.
If you haven't done so already, take a few minutes
and describe three projects you'd like to create.

Exceptions help you respond appropriately to errors that
are likely to occur. You place code that might cause an
error in the try block. Code that should run in response to
an error goes in the except block. Code that should run only
if the try block was successful goes in the else block.

Catching an exception
prompt = "How many tickets do you need? "
num_tickets = input(prompt)
try:
num_tickets = int(num_tickets)
except ValueError:
print("Please try again.")
else:
print("Your tickets are printing.")

Simple is better than complex

If you have a choice between a simple and a complex
solution, and both work, use the simple solution. Your
code will be easier to maintain, and it will be easier
for you and others to build on that code later on.

More cheat sheets available at

You can add elements to the end of a list, or you can insert
them wherever you like in a list.

Adding an element to the end of the list
users.append('amy')

Starting with an empty list
A list stores a series of items in a particular order.
Lists allow you to store sets of information in one
place, whether you have just a few items or millions
of items. Lists are one of Python's most powerful
features readily accessible to new programmers, and
they tie together many important concepts in
programming.

users = []
users.append('val')
users.append('bob')
users.append('mia')

Inserting elements at a particular position
users.insert(0, 'joe')
users.insert(3, 'bea')

You can remove elements by their position in a list, or by
the value of the item. If you remove an item by its value,
Python removes only the first item that has that value.

Making a list

Deleting an element by its position
del users[-1]

Removing an item by its value
users.remove('mia')
Individual elements in a list are accessed according to their
position, called the index. The index of the first element is
0, the index of the second element is 1, and so forth.
Negative indices refer to items at the end of the list. To get
a particular element, write the name of the list and then the
index of the element in square brackets.

Getting the first element
first_user = users[0]

Getting the second element
second_user = users[1]

Getting the last element
newest_user = users[-1]

Once you've defined a list, you can change individual
elements in the list. You do this by referring to the index of
the item you want to modify.

Changing an element
users[0] = 'valerie'
users[-2] = 'ronald'

Sorting a list permanently
users.sort()

Sorting a list permanently in reverse alphabetical
order
users.sort(reverse=True)

Sorting a list temporarily
print(sorted(users))
print(sorted(users, reverse=True))

Use square brackets to define a list, and use commas to
separate individual items in the list. Use plural names for
lists, to make your code easier to read.

users = ['val', 'bob', 'mia', 'ron', 'ned']

The sort() method changes the order of a list permanently.
The sorted() function returns a copy of the list, leaving the
original list unchanged. You can sort the items in a list in
alphabetical order, or reverse alphabetical order. You can
also reverse the original order of the list. Keep in mind that
lowercase and uppercase letters may affect the sort order.

If you want to work with an element that you're removing
from the list, you can "pop" the element. If you think of the
list as a stack of items, pop() takes an item off the top of the
stack. By default pop() returns the last element in the list,
but you can also pop elements from any position in the list.

Pop the last item from a list
most_recent_user = users.pop()
print(most_recent_user)

Pop the first item in a list
first_user = users.pop(0)
print(first_user)

Reversing the order of a list
users.reverse()

Lists can contain millions of items, so Python provides an
efficient way to loop through all the items in a list. When
you set up a loop, Python pulls each item from the list one
at a time and stores it in a temporary variable, which you
provide a name for. This name should be the singular
version of the list name.
The indented block of code makes up the body of the
loop, where you can work with each individual item. Any
lines that are not indented run after the loop is completed.

Printing all items in a list
for user in users:
print(user)

Printing a message for each item, and a separate
message afterwards
for user in users:
print("Welcome, " + user + "!")
print("Welcome, we're glad to see you all!")

The len() function returns the number of items in a list.

Find the length of a list
num_users = len(users)
print("We have " + str(num_users) + " users.")

Covers Python 3 and Python 2

You can use the range() function to work with a set of
numbers efficiently. The range() function starts at 0 by
default, and stops one number below the number passed to
it. You can use the list() function to efficiently generate a
large list of numbers.

Printing the numbers 0 to 1000
for number in range(1001):
print(number)

To copy a list make a slice that starts at the first item and
ends at the last item. If you try to copy a list without using
this approach, whatever you do to the copied list will affect
the original list as well.

Making a copy of a list
finishers = ['kai', 'abe', 'ada', 'gus', 'zoe']
copy_of_finishers = finishers[:]

Making a list of numbers from 1 to a million
numbers = list(range(1, 1000001))

There are a number of simple statistics you can run on a list
containing numerical data.

Finding the minimum value in a list
ages = [93, 99, 66, 17, 85, 1, 35, 82, 2, 77]
youngest = min(ages)

Finding the maximum value
ages = [93, 99, 66, 17, 85, 1, 35, 82, 2, 77]
oldest = max(ages)

Finding the sum of all values
ages = [93, 99, 66, 17, 85, 1, 35, 82, 2, 77]
total_years = sum(ages)

You can work with any set of elements from a list. A portion
of a list is called a slice. To slice a list start with the index of
the first item you want, then add a colon and the index after
the last item you want. Leave off the first index to start at
the beginning of the list, and leave off the last index to slice
through the end of the list.

Getting the first three items

You can use a loop to generate a list based on a range of
numbers or on another list. This is a common operation, so
Python offers a more efficient way to do it. List
comprehensions may look complicated at first; if so, use the
for loop approach until you're ready to start using
comprehensions.
To write a comprehension, define an expression for the
values you want to store in the list. Then write a for loop to
generate input values needed to make the list.

middle_three = finishers[1:4]

Getting the last three items
last_three = finishers[-3:]

dimensions = (800, 600)

for dimension in dimensions:
print(dimension)

Overwriting a tuple
dimensions = (800, 600)
print(dimensions)
dimensions = (1200, 900)

Using a loop to generate a list of square numbers
squares = []
for x in range(1, 11):
square = x**2
squares.append(square)

Using a comprehension to generate a list of square
numbers
squares = [x**2 for x in range(1, 11)]

Using a loop to convert a list of names to upper case
names = ['kai', 'abe', 'ada', 'gus', 'zoe']
upper_names = []
for name in names:
upper_names.append(name.upper())

Using a comprehension to convert a list of names to
upper case
names = ['kai', 'abe', 'ada', 'gus', 'zoe']
upper_names = [name.upper() for name in names]

finishers = ['kai', 'abe', 'ada', 'gus', 'zoe']
first_three = finishers[:3]

Getting the middle three items

Defining a tuple
Looping through a tuple

Printing the numbers 1 to 1000
for number in range(1, 1001):
print(number)

A tuple is like a list, except you can't change the values in a
tuple once it's defined. Tuples are good for storing
information that shouldn't be changed throughout the life of
a program. Tuples are designated by parentheses instead
of square brackets. (You can overwrite an entire tuple, but
you can't change the individual elements in a tuple.)

Readability counts

 Use four spaces per indentation level.
 Keep your lines to 79 characters or fewer.
 Use single blank lines to group parts of your
program visually.

When you're first learning about data structures such as
lists, it helps to visualize how Python is working with the
information in your program. pythontutor.com is a great tool
for seeing how Python keeps track of the information in a
list. Try running the following code on pythontutor.com, and
then run your own code.

Build a list and print the items in the list
dogs = []
dogs.append('willie')
dogs.append('hootz')
dogs.append('peso')
dogs.append('goblin')
for dog in dogs:
print("Hello " + dog + "!")
print("I love these dogs!")
print("\nThese were my first two dogs:")
old_dogs = dogs[:2]
for old_dog in old_dogs:
print(old_dog)
del dogs[0]
dogs.remove('peso')
print(dogs)

More cheat sheets available at

You can store as many key-value pairs as you want in a
dictionary, until your computer runs out of memory. To add
a new key-value pair to an existing dictionary give the name
of the dictionary and the new key in square brackets, and
set it equal to the new value.
This also allows you to start with an empty dictionary and
add key-value pairs as they become relevant.

You can loop through a dictionary in three ways: you can
loop through all the key-value pairs, all the keys, or all the
values.
A dictionary only tracks the connections between keys
and values; it doesn't track the order of items in the
dictionary. If you want to process the information in order,
you can sort the keys in your loop.

Adding a key-value pair

Looping through all key-value pairs

alien_0 = {'color': 'green', 'points': 5}

Python's dictionaries allow you to connect pieces of
related information. Each piece of information in a
dictionary is stored as a key-value pair. When you
provide a key, Python returns the value associated
with that key. You can loop through all the key-value
pairs, all the keys, or all the values.

Use curly braces to define a dictionary. Use colons to
connect keys and values, and use commas to separate
individual key-value pairs.

Making a dictionary
alien_0 = {'color': 'green', 'points': 5}

To access the value associated with an individual key give
the name of the dictionary and then place the key in a set of
square brackets. If the key you're asking for is not in the
dictionary, an error will occur.
You can also use the get() method, which returns None
instead of an error if the key doesn't exist. You can also
specify a default value to use if the key is not in the
dictionary.

Getting the value associated with a key
alien_0 = {'color': 'green', 'points': 5}
print(alien_0['color'])
print(alien_0['points'])

Getting the value with get()

alien_0['x'] = 0
alien_0['y'] = 25
alien_0['speed'] = 1.5

Adding to an empty dictionary
alien_0 = {}
alien_0['color'] = 'green'
alien_0['points'] = 5

# Store people's favorite languages.
fav_languages = {
'jen': 'python',
'sarah': 'c',
'edward': 'ruby',
'phil': 'python',
}
# Show each person's favorite language.
for name, language in fav_languages.items():
print(name + ": " + language)

Looping through all the keys
You can modify the value associated with any key in a
dictionary. To do so give the name of the dictionary and
enclose the key in square brackets, then provide the new
value for that key.

Modifying values in a dictionary
alien_0 = {'color': 'green', 'points': 5}
print(alien_0)
# Change the alien's color and point value.
alien_0['color'] = 'yellow'
alien_0['points'] = 10
print(alien_0)

You can remove any key-value pair you want from a
dictionary. To do so use the del keyword and the dictionary
name, followed by the key in square brackets. This will
delete the key and its associated value.

Deleting a key-value pair

# Show everyone who's taken the survey.
for name in fav_languages.keys():
print(name)

Looping through all the values
# Show all the languages that have been chosen.
for language in fav_languages.values():
print(language)

Looping through all the keys in order
# Show each person's favorite language,
#
in order by the person's name.
for name in sorted(fav_languages.keys()):
print(name + ": " + language)

You can find the number of key-value pairs in a dictionary.

Finding a dictionary's length
num_responses = len(fav_languages)

alien_0 = {'color': 'green', 'points': 5}
print(alien_0)

alien_0 = {'color': 'green'}
alien_color = alien_0.get('color')
alien_points = alien_0.get('points', 0)
print(alien_color)
print(alien_points)

del alien_0['points']
print(alien_0)

Try running some of these examples on pythontutor.com.

Covers Python 3 and Python 2

It's sometimes useful to store a set of dictionaries in a list;
this is called nesting.

Storing a list inside a dictionary alows you to associate
more than one value with each key.

Storing dictionaries in a list

Storing lists in a dictionary

# Start with an empty list.
users = []
# Make a new user, and add them to the list.
new_user = {
'last': 'fermi',
'first': 'enrico',
'username': 'efermi',
}
users.append(new_user)
# Make another new user, and add them as well.
new_user = {
'last': 'curie',
'first': 'marie',
'username': 'mcurie',
}
users.append(new_user)
# Show all information about each user.
for user_dict in users:
for k, v in user_dict.items():
print(k + ": " + v)
print("\n")

You can also define a list of dictionaries directly,
without using append():
# Define a list of users, where each user
#
is represented by a dictionary.
users = [
{
'last': 'fermi',
'first': 'enrico',
'username': 'efermi',
},
{
'last': 'curie',
'first': 'marie',
'username': 'mcurie',
},
]
# Show all information about each user.
for user_dict in users:
for k, v in user_dict.items():
print(k + ": " + v)
print("\n")

# Store multiple languages for each person.
fav_languages = {
'jen': ['python', 'ruby'],
'sarah': ['c'],
'edward': ['ruby', 'go'],
'phil': ['python', 'haskell'],
}
# Show all responses for each person.
for name, langs in fav_languages.items():
print(name + ": ")
for lang in langs:
print("- " + lang)

You can store a dictionary inside another dictionary. In this
case each value associated with a key is itself a dictionary.

Storing dictionaries in a dictionary
users = {
'aeinstein': {
'first': 'albert',
'last': 'einstein',
'location': 'princeton',
},
'mcurie': {
'first': 'marie',
'last': 'curie',
'location': 'paris',
},
}
for username, user_dict in users.items():
print("\nUsername: " + username)
full_name = user_dict['first'] + " "
full_name += user_dict['last']
location = user_dict['location']
print("\tFull name: " + full_name.title())
print("\tLocation: " + location.title())

Nesting is extremely useful in certain situations. However,
be aware of making your code overly complex. If you're
nesting items much deeper than what you see here there
are probably simpler ways of managing your data, such as
using classes.

Standard Python dictionaries don't keep track of the order
in which keys and values are added; they only preserve the
association between each key and its value. If you want to
preserve the order in which keys and values are added, use
an OrderedDict.

Preserving the order of keys and values
from collections import OrderedDict
# Store each person's languages, keeping
# track of who respoded first.
fav_languages = OrderedDict()
fav_languages['jen'] = ['python', 'ruby']
fav_languages['sarah'] = ['c']
fav_languages['edward'] = ['ruby', 'go']
fav_languages['phil'] = ['python', 'haskell']
# Display the results, in the same order they
# were entered.
for name, langs in fav_languages.items():
print(name + ":")
for lang in langs:
print("- " + lang)

You can use a loop to generate a large number of
dictionaries efficiently, if all the dictionaries start out with
similar data.

A million aliens
aliens = []
# Make a million green aliens, worth 5 points
# each. Have them all start in one row.
for alien_num in range(1000000):
new_alien = {}
new_alien['color'] = 'green'
new_alien['points'] = 5
new_alien['x'] = 20 * alien_num
new_alien['y'] = 0
aliens.append(new_alien)
# Prove the list contains a million aliens.
num_aliens = len(aliens)
print("Number of aliens created:")
print(num_aliens)

More cheat sheets available at

Testing numerical values is similar to testing string values.

Testing equality and inequality
>>> age = 18
>>> age == 18
True
>>> age != 18
False

Comparison operators

If statements allow you to examine the current state
of a program and respond appropriately to that state.
You can write a simple if statement that checks one
condition, or you can create a complex series of if
statements that idenitfy the exact conditions you're
looking for.
While loops run as long as certain conditions remain
true. You can use while loops to let your programs
run as long as your users want them to.

A conditional test is an expression that can be evaluated as
True or False. Python uses the values True and False to
decide whether the code in an if statement should be
executed.

Checking for equality
A single equal sign assigns a value to a variable. A double equal
sign (==) checks whether two values are equal.

>>> car
>>> car
True
>>> car
>>> car
False

= 'bmw'
== 'bmw'
= 'audi'
== 'bmw'

>>> age
>>> age
True
>>> age
True
>>> age
False
>>> age
False

= 19
< 21

Several kinds of if statements exist. Your choice of which to
use depends on the number of conditions you need to test.
You can have as many elif blocks as you need, and the
else block is always optional.

Simple if statement
age = 19
if age >= 18:
print("You're old enough to vote!")

If-else statements
age = 17

<= 21
> 21
>= 21

if age >= 18:
print("You're old enough to vote!")
else:
print("You can't vote yet.")

The if-elif-else chain
age = 12

You can check multiple conditions at the same time. The
and operator returns True if all the conditions listed are
True. The or operator returns True if any condition is True.

Using and to check multiple conditions
>>> age_0
>>> age_1
>>> age_0
False
>>> age_1
>>> age_0
True

= 22
= 18
>= 21 and age_1 >= 21

print("Your cost is $" + str(price) + ".")

= 23
>= 21 and age_1 >= 21

Using or to check multiple conditions
>>> age_0
>>> age_1
>>> age_0
True
>>> age_0
>>> age_0
False

if age < 4:
price = 0
elif age < 18:
price = 5
else:
price = 10

= 22
= 18
>= 21 or age_1 >= 21
= 18
>= 21 or age_1 >= 21

You can easily test whether a certain value is in a list. You
can also test whether a list is empty before trying to loop
through the list.

Testing if a value is in a list
>>> players = ['al', 'bea', 'cyn', 'dale']
>>> 'al' in players
True
>>> 'eric' in players
False

Ignoring case when making a comparison
>>> car = 'Audi'
>>> car.lower() == 'audi'
True

Checking for inequality
>>> topping = 'mushrooms'
>>> topping != 'anchovies'
True

A boolean value is either True or False. Variables with
boolean values are often used to keep track of certain
conditions within a program.

Simple boolean values
game_active = True
can_edit = False

Covers Python 3 and Python 2

Testing if a value is not in a list
banned_users = ['ann', 'chad', 'dee']
user = 'erin'
if user not in banned_users:
print("You can play!")

Checking if a list is empty
players = []
if players:
for player in players:
print("Player: " + player.title())
else:
print("We have no players yet!")

You can allow your users to enter input using the input()
statement. In Python 3, all input is stored as a string.

Simple input
name = input("What's your name? ")
print("Hello, " + name + ".")

Accepting numerical input
age = input("How old are you? ")
age = int(age)
if age >= 18:
print("\nYou can vote!")
else:
print("\nYou can't vote yet.")

Accepting input in Python 2.7
Use raw_input() in Python 2.7. This function interprets all input as a
string, just as input() does in Python 3.

Letting the user choose when to quit
prompt = "\nTell me something, and I'll "
prompt += "repeat it back to you."
prompt += "\nEnter 'quit' to end the program. "
message = ""
while message != 'quit':
message = input(prompt)

while current_number <= 5:
print(current_number)
current_number += 1

prompt = "\nAdd a player to your team."
prompt += "\nEnter 'quit' when you're done. "

prompt = "\nTell me something, and I'll "
prompt += "repeat it back to you."
prompt += "\nEnter 'quit' to end the program. "
active = True
while active:
message = input(prompt)

print("\nYour team:")
for player in players:
print(player)

if message != 'quit':
print(message)

Using a flag

if message == 'quit':
active = False
else:
print(message)

Using break to exit a loop
prompt = "\nWhat cities have you visited?"
prompt += "\nEnter 'quit' when you're done. "
while True:
city = input(prompt)
if city == 'quit':
break
else:
print("I've been to " + city + "!")

Every while loop needs a way to stop running so it won't
continue to run forever. If there's no way for the condition to
become False, the loop will never stop running.

An infinite loop
while True:
name = input("\nWho are you? ")
print("Nice to meet you, " + name + "!")

The remove() method removes a specific value from a list,
but it only removes the first instance of the value you
provide. You can use a while loop to remove all instances
of a particular value.

Removing all cats from a list of pets
Sublime Text doesn't run programs that prompt the user for
input. You can use Sublime Text to write programs that
prompt for input, but you'll need to run these programs from
a terminal.

Counting to 5
current_number = 1

banned_users = ['eve', 'fred', 'gary', 'helen']

players = []
while True:
player = input(prompt)
if player == 'quit':
break
elif player in banned_users:
print(player + " is banned!")
continue
else:
players.append(player)

name = raw_input("What's your name? ")
print("Hello, " + name + ".")

A while loop repeats a block of code as long as a condition
is True.

Using continue in a loop

You can use the break statement and the continue
statement with any of Python's loops. For example you can
use break to quit a for loop that's working through a list or a
dictionary. You can use continue to skip over certain items
when looping through a list or dictionary as well.

pets = ['dog', 'cat', 'dog', 'fish', 'cat',
'rabbit', 'cat']
print(pets)
while 'cat' in pets:
pets.remove('cat')
print(pets)

More cheat sheets available at

The two main kinds of arguments are positional and
keyword arguments. When you use positional arguments
Python matches the first argument in the function call with
the first parameter in the function definition, and so forth.
With keyword arguments, you specify which parameter
each argument should be assigned to in the function call.
When you use keyword arguments, the order of the
arguments doesn't matter.

Using positional arguments
Functions are named blocks of code designed to do
one specific job. Functions allow you to write code
once that can then be run whenever you need to
accomplish the same task. Functions can take in the
information they need, and return the information they
generate. Using functions effectively makes your
programs easier to write, read, test, and fix.

The first line of a function is its definition, marked by the
keyword def. The name of the function is followed by a set
of parentheses and a colon. A docstring, in triple quotes,
describes what the function does. The body of a function is
indented one level.
To call a function, give the name of the function followed
by a set of parentheses.

def describe_pet(animal, name):
"""Display information about a pet."""
print("\nI have a " + animal + ".")
print("Its name is " + name + ".")
describe_pet('hamster', 'harry')
describe_pet('dog', 'willie')

Using keyword arguments
def describe_pet(animal, name):
"""Display information about a pet."""
print("\nI have a " + animal + ".")
print("Its name is " + name + ".")
describe_pet(animal='hamster', name='harry')
describe_pet(name='willie', animal='dog')

def greet_user():
"""Display a simple greeting."""
print("Hello!")

You can provide a default value for a parameter. When
function calls omit this argument the default value will be
used. Parameters with default values must be listed after
parameters without default values in the function's definition
so positional arguments can still work correctly.

greet_user()

Using a default value

Making a function

Information that's passed to a function is called an
argument; information that's received by a function is called
a parameter. Arguments are included in parentheses after
the function's name, and parameters are listed in
parentheses in the function's definition.

Passing a single argument
def greet_user(username):
"""Display a simple greeting."""
print("Hello, " + username + "!")
greet_user('jesse')
greet_user('diana')
greet_user('brandon')

def describe_pet(name, animal='dog'):
"""Display information about a pet."""
print("\nI have a " + animal + ".")
print("Its name is " + name + ".")

A function can return a value or a set of values. When a
function returns a value, the calling line must provide a
variable in which to store the return value. A function stops
running when it reaches a return statement.

Returning a single value
def get_full_name(first, last):
"""Return a neatly formatted full name."""
full_name = first + ' ' + last
return full_name.title()
musician = get_full_name('jimi', 'hendrix')
print(musician)

Returning a dictionary
def build_person(first, last):
"""Return a dictionary of information
about a person.
"""
person = {'first': first, 'last': last}
return person
musician = build_person('jimi', 'hendrix')
print(musician)

Returning a dictionary with optional values
def build_person(first, last, age=None):
"""Return a dictionary of information
about a person.
"""
person = {'first': first, 'last': last}
if age:
person['age'] = age
return person
musician = build_person('jimi', 'hendrix', 27)
print(musician)
musician = build_person('janis', 'joplin')
print(musician)

describe_pet('harry', 'hamster')
describe_pet('willie')

Using None to make an argument optional
def describe_pet(animal, name=None):
"""Display information about a pet."""
print("\nI have a " + animal + ".")
if name:
print("Its name is " + name + ".")
describe_pet('hamster', 'harry')
describe_pet('snake')

Try running some of these examples on pythontutor.com.

Covers Python 3 and Python 2

You can pass a list as an argument to a function, and the
function can work with the values in the list. Any changes
the function makes to the list will affect the original list. You
can prevent a function from modifying a list by passing a
copy of the list as an argument.

Passing a list as an argument
def greet_users(names):
"""Print a simple greeting to everyone."""
for name in names:
msg = "Hello, " + name + "!"
print(msg)
usernames = ['hannah', 'ty', 'margot']
greet_users(usernames)

Allowing a function to modify a list
The following example sends a list of models to a function for
printing. The original list is emptied, and the second list is filled.

def print_models(unprinted, printed):
"""3d print a set of models."""
while unprinted:
current_model = unprinted.pop()
print("Printing " + current_model)
printed.append(current_model)
# Store some unprinted designs,
# and print each of them.
unprinted = ['phone case', 'pendant', 'ring']
printed = []
print_models(unprinted, printed)

Sometimes you won't know how many arguments a
function will need to accept. Python allows you to collect an
arbitrary number of arguments into one parameter using the
* operator. A parameter that accepts an arbitrary number of
arguments must come last in the function definition.
The ** operator allows a parameter to collect an arbitrary
number of keyword arguments.

Collecting an arbitrary number of arguments
def make_pizza(size, *toppings):
"""Make a pizza."""
print("\nMaking a " + size + " pizza.")
print("Toppings:")
for topping in toppings:
print("- " + topping)
# Make three pizzas with different toppings.
make_pizza('small', 'pepperoni')
make_pizza('large', 'bacon bits', 'pineapple')
make_pizza('medium', 'mushrooms', 'peppers',
'onions', 'extra cheese')

Collecting an arbitrary number of keyword arguments
def build_profile(first, last, **user_info):
"""Build a user's profile dictionary."""
# Build a dict with the required keys.
profile = {'first': first, 'last': last}
# Add any other keys and values.
for key, value in user_info.items():
profile[key] = value

You can store your functions in a separate file called a
module, and then import the functions you need into the file
containing your main program. This allows for cleaner
program files. (Make sure your module is stored in the
same directory as your main program.)

Storing a function in a module
File: pizza.py

def make_pizza(size, *toppings):
"""Make a pizza."""
print("\nMaking a " + size + " pizza.")
print("Toppings:")
for topping in toppings:
print("- " + topping)

Importing an entire module
File: making_pizzas.py
Every function in the module is available in the program file.

import pizza
pizza.make_pizza('medium', 'pepperoni')
pizza.make_pizza('small', 'bacon', 'pineapple')

Importing a specific function
Only the imported functions are available in the program file.

from pizza import make_pizza
make_pizza('medium', 'pepperoni')
make_pizza('small', 'bacon', 'pineapple')

Giving a module an alias
import pizza as p

print("\nUnprinted:", unprinted)
print("Printed:", printed)

Preventing a function from modifying a list
The following example is the same as the previous one, except the
original list is unchanged after calling print_models().

def print_models(unprinted, printed):
"""3d print a set of models."""
while unprinted:
current_model = unprinted.pop()
print("Printing " + current_model)
printed.append(current_model)
# Store some unprinted designs,
# and print each of them.
original = ['phone case', 'pendant', 'ring']
printed = []
print_models(original[:], printed)
print("\nOriginal:", original)
print("Printed:", printed)

return profile
# Create two users with different kinds
#
of information.
user_0 = build_profile('albert', 'einstein',
location='princeton')
user_1 = build_profile('marie', 'curie',
location='paris', field='chemistry')
print(user_0)
print(user_1)

As you can see there are many ways to write and call a
function. When you're starting out, aim for something that
simply works. As you gain experience you'll develop an
understanding of the more subtle advantages of different
structures such as positional and keyword arguments, and
the various approaches to importing functions. For now if
your functions do what you need them to, you're doing well.

p.make_pizza('medium', 'pepperoni')
p.make_pizza('small', 'bacon', 'pineapple')

Giving a function an alias
from pizza import make_pizza as mp
mp('medium', 'pepperoni')
mp('small', 'bacon', 'pineapple')

Importing all functions from a module
Don't do this, but recognize it when you see it in others' code. It
can result in naming conflicts, which can cause errors.

from pizza import *
make_pizza('medium', 'pepperoni')
make_pizza('small', 'bacon', 'pineapple')

More cheat sheets available at

Creating an object from a class
my_car = Car('audi', 'a4', 2016)

Accessing attribute values
print(my_car.make)
print(my_car.model)
print(my_car.year)

Classes are the foundation of object-oriented
programming. Classes represent real-world things
you want to model in your programs: for example
dogs, cars, and robots. You use a class to make
objects, which are specific instances of dogs, cars,
and robots. A class defines the general behavior that
a whole category of objects can have, and the
information that can be associated with those objects.
Classes can inherit from each other – you can
write a class that extends the functionality of an
existing class. This allows you to code efficiently for a
wide variety of situations.

Calling methods
my_car.fill_tank()
my_car.drive()

Creating multiple objects
my_car = Car('audi', 'a4', 2016)
my_old_car = Car('subaru', 'outback', 2013)
my_truck = Car('toyota', 'tacoma', 2010)

You can modify an attribute's value directly, or you can
write methods that manage updating values more carefully.

Modifying an attribute directly
Consider how we might model a car. What information
would we associate with a car, and what behavior would it
have? The information is stored in variables called
attributes, and the behavior is represented by functions.
Functions that are part of a class are called methods.

The Car class
class Car():
"""A simple attempt to model a car."""
def __init__(self, make, model, year):
"""Initialize car attributes."""
self.make = make
self.model = model
self.year = year
# Fuel capacity and level in gallons.
self.fuel_capacity = 15
self.fuel_level = 0
def fill_tank(self):
"""Fill gas tank to capacity."""
self.fuel_level = self.fuel_capacity
print("Fuel tank is full.")
def drive(self):
"""Simulate driving."""
print("The car is moving.")

my_new_car = Car('audi', 'a4', 2016)
my_new_car.fuel_level = 5

Writing a method to update an attribute's value
def update_fuel_level(self, new_level):
"""Update the fuel level."""
if new_level <= self.fuel_capacity:
self.fuel_level = new_level
else:
print("The tank can't hold that much!")

Writing a method to increment an attribute's value
def add_fuel(self, amount):
"""Add fuel to the tank."""
if (self.fuel_level + amount
<= self.fuel_capacity):
self.fuel_level += amount
print("Added fuel.")
else:
print("The tank won't hold that much.")

In Python class names are written in CamelCase and object
names are written in lowercase with underscores. Modules
that contain classes should still be named in lowercase with
underscores.

If the class you're writing is a specialized version of another
class, you can use inheritance. When one class inherits
from another, it automatically takes on all the attributes and
methods of the parent class. The child class is free to
introduce new attributes and methods, and override
attributes and methods of the parent class.
To inherit from another class include the name of the
parent class in parentheses when defining the new class.

The __init__() method for a child class
class ElectricCar(Car):
"""A simple model of an electric car."""
def __init__(self, make, model, year):
"""Initialize an electric car."""
super().__init__(make, model, year)
# Attributes specific to electric cars.
# Battery capacity in kWh.
self.battery_size = 70
# Charge level in %.
self.charge_level = 0

Adding new methods to the child class
class ElectricCar(Car):
--snip-def charge(self):
"""Fully charge the vehicle."""
self.charge_level = 100
print("The vehicle is fully charged.")

Using child methods and parent methods
my_ecar = ElectricCar('tesla', 'model s', 2016)
my_ecar.charge()
my_ecar.drive()

There are many ways to model real world objects and
situations in code, and sometimes that variety can feel
overwhelming. Pick an approach and try it – if your first
attempt doesn't work, try a different approach.

Covers Python 3 and Python 2

Overriding parent methods
class ElectricCar(Car):
--snip-def fill_tank(self):
"""Display an error message."""
print("This car has no fuel tank!")

A class can have objects as attributes. This allows classes
to work together to model complex situations.

A Battery class
class Battery():
"""A battery for an electric car."""
def __init__(self, size=70):
"""Initialize battery attributes."""
# Capacity in kWh, charge level in %.
self.size = size
self.charge_level = 0
def get_range(self):
"""Return the battery's range."""
if self.size == 70:
return 240
elif self.size == 85:
return 270

Using an instance as an attribute
class ElectricCar(Car):
--snip--

Class files can get long as you add detailed information and
functionality. To help keep your program files uncluttered,
you can store your classes in modules and import the
classes you need into your main program.

Storing classes in a file
car.py

"""Represent gas and electric cars."""
class Car():
"""A simple attempt to model a car."""
--snip—
class Battery():
"""A battery for an electric car."""
--snip-class ElectricCar(Car):
"""A simple model of an electric car."""
--snip--

Importing individual classes from a module
my_cars.py

from car import Car, ElectricCar
my_beetle = Car('volkswagen', 'beetle', 2016)
my_beetle.fill_tank()
my_beetle.drive()
my_tesla = ElectricCar('tesla', 'model s',
2016)
my_tesla.charge()
my_tesla.drive()

Importing an entire module
def __init__(self, make, model, year):
"""Initialize an electric car."""
super().__init__(make, model, year)
# Attribute specific to electric cars.
self.battery = Battery()
def charge(self):
"""Fully charge the vehicle."""
self.battery.charge_level = 100
print("The vehicle is fully charged.")

Using the instance
my_ecar = ElectricCar('tesla', 'model x', 2016)
my_ecar.charge()
print(my_ecar.battery.get_range())
my_ecar.drive()

import car
my_beetle = car.Car(
'volkswagen', 'beetle', 2016)
my_beetle.fill_tank()
my_beetle.drive()
my_tesla = car.ElectricCar(
'tesla', 'model s', 2016)
my_tesla.charge()
my_tesla.drive()

Importing all classes from a module
(Don’t do this, but recognize it when you see it.)

from car import *
my_beetle = Car('volkswagen', 'beetle', 2016)

Classes should inherit from object
class ClassName(object):

The Car class in Python 2.7
class Car(object):

Child class __init__() method is different
class ChildClassName(ParentClass):
def __init__(self):
super(ClassName, self).__init__()

The ElectricCar class in Python 2.7
class ElectricCar(Car):
def __init__(self, make, model, year):
super(ElectricCar, self).__init__(
make, model, year)

A list can hold as many items as you want, so you can
make a large number of objects from a class and store
them in a list.
Here's an example showing how to make a fleet of rental
cars, and make sure all the cars are ready to drive.

A fleet of rental cars
from car import Car, ElectricCar
# Make lists to hold a fleet of cars.
gas_fleet = []
electric_fleet = []
# Make 500 gas cars and 250 electric cars.
for _ in range(500):
car = Car('ford', 'focus', 2016)
gas_fleet.append(car)
for _ in range(250):
ecar = ElectricCar('nissan', 'leaf', 2016)
electric_fleet.append(ecar)
# Fill the gas cars, and charge electric cars.
for car in gas_fleet:
car.fill_tank()
for ecar in electric_fleet:
ecar.charge()
print("Gas cars:", len(gas_fleet))
print("Electric cars:", len(electric_fleet))

More cheat sheets available at

Storing the lines in a list

Opening a file using an absolute path

filename = 'siddhartha.txt'

f_path = "/home/ehmatthes/books/alice.txt"

with open(filename) as f_obj:
lines = f_obj.readlines()

with open(f_path) as f_obj:
lines = f_obj.readlines()

for line in lines:
print(line.rstrip())

Opening a file on Windows
Windows will sometimes interpret forward slashes incorrectly. If
you run into this, use backslashes in your file paths.

f_path = "C:\Users\ehmatthes\books\alice.txt"

Your programs can read information in from files, and
they can write data to files. Reading from files allows
you to work with a wide variety of information; writing
to files allows users to pick up where they left off the
next time they run your program. You can write text to
files, and you can store Python structures such as
lists in data files.
Exceptions are special objects that help your
programs respond to errors in appropriate ways. For
example if your program tries to open a file that
doesn’t exist, you can use exceptions to display an
informative error message instead of having the
program crash.

To read from a file your program needs to open the file and
then read the contents of the file. You can read the entire
contents of the file at once, or read the file line by line. The
with statement makes sure the file is closed properly when
the program has finished accessing the file.

Reading an entire file at once

Passing the 'w' argument to open() tells Python you want to
write to the file. Be careful; this will erase the contents of
the file if it already exists. Passing the 'a' argument tells
Python you want to append to the end of an existing file.

Writing to an empty file
filename = 'programming.txt'
with open(filename, 'w') as f:
f.write("I love programming!")

Writing multiple lines to an empty file
filename = 'programming.txt'
with open(filename, 'w') as f:
f.write("I love programming!\n")
f.write("I love creating new games.\n")

Appending to a file
filename = 'programming.txt'
with open(filename, 'a') as f:
f.write("I also love working with data.\n")
f.write("I love making apps as well.\n")

filename = 'siddhartha.txt'
with open(filename) as f_obj:
contents = f_obj.read()
print(contents)

Reading line by line
Each line that's read from the file has a newline character at the
end of the line, and the print function adds its own newline
character. The rstrip() method gets rid of the the extra blank lines
this would result in when printing to the terminal.

filename = 'siddhartha.txt'
with open(filename) as f_obj:
for line in f_obj:
print(line.rstrip())

When Python runs the open() function, it looks for the file in
the same directory where the program that's being excuted
is stored. You can open a file from a subfolder using a
relative path. You can also use an absolute path to open
any file on your system.

with open(f_path) as f_obj:
lines = f_obj.readlines()

When you think an error may occur, you can write a tryexcept block to handle the exception that might be raised.
The try block tells Python to try running some code, and the
except block tells Python what to do if the code results in a
particular kind of error.

Handling the ZeroDivisionError exception
try:
print(5/0)
except ZeroDivisionError:
print("You can't divide by zero!")

Handling the FileNotFoundError exception
f_name = 'siddhartha.txt'
try:
with open(f_name) as f_obj:
lines = f_obj.readlines()
except FileNotFoundError:
msg = "Can't find file {0}.".format(f_name)
print(msg)

It can be hard to know what kind of exception to handle
when writing code. Try writing your code without a try block,
and make it generate an error. The traceback will tell you
what kind of exception your program needs to handle.

Opening a file from a subfolder
f_path = "text_files/alice.txt"
with open(f_path) as f_obj:
lines = f_obj.readlines()
for line in lines:
print(line.rstrip())

Covers Python 3 and Python 2

The try block should only contain code that may cause an
error. Any code that depends on the try block running
successfully should be placed in the else block.

Using an else block
print("Enter two numbers. I'll divide them.")
x = input("First number: ")
y = input("Second number: ")
try:
result = int(x) / int(y)
except ZeroDivisionError:
print("You can't divide by zero!")
else:
print(result)

Preventing crashes from user input
Without the except block in the following example, the program
would crash if the user tries to divide by zero. As written, it will
handle the error gracefully and keep running.

"""A simple calculator for division only."""

Sometimes you want your program to just continue running
when it encounters an error, without reporting the error to
the user. Using the pass statement in an else block allows
you to do this.

Using the pass statement in an else block
f_names = ['alice.txt', 'siddhartha.txt',
'moby_dick.txt', 'little_women.txt']

Knowing how to manage exceptions is important when
working with stored data. You'll usually want to make sure
the data you're trying to load exists before working with it.

for f_name in f_names:
# Report the length of each file found.
try:
with open(f_name) as f_obj:
lines = f_obj.readlines()
except FileNotFoundError:
# Just move on to the next file.
pass
else:
num_lines = len(lines)
msg = "{0} has {1} lines.".format(
f_name, num_lines)
print(msg)

Using json.dump() to store data

try:
result = int(x) / int(y)
except ZeroDivisionError:
print("You can't divide by zero!")
else:
print(result)

Exception-handling code should catch specific exceptions
that you expect to happen during your program's execution.
A bare except block will catch all exceptions, including
keyboard interrupts and system exits you might need when
forcing a program to close.
If you want to use a try block and you're not sure which
exception to catch, use Exception. It will catch most
exceptions, but still allow you to interrupt programs
intentionally.

Don’t use bare except blocks
try:
# Do something
except:
pass

Use Exception instead
Well-written, properly tested code is not very prone to
internal errors such as syntax or logical errors. But every
time your program depends on something external such as
user input or the existence of a file, there's a possibility of
an exception being raised.

try:
# Do something
except Exception:
pass

Printing the exception
It's up to you how to communicate errors to your users.
Sometimes users need to know if a file is missing;
sometimes it's better to handle the error silently. A little
experience will help you know how much to report.

"""Store some numbers."""
import json
numbers = [2, 3, 5, 7, 11, 13]
filename = 'numbers.json'
with open(filename, 'w') as f_obj:
json.dump(numbers, f_obj)

Using json.load() to read data
"""Load some previously stored numbers."""

print("Enter two numbers. I'll divide them.")
print("Enter 'q' to quit.")
while True:
x = input("\nFirst number: ")
if x == 'q':
break
y = input("Second number: ")
if y == 'q':
break

The json module allows you to dump simple Python data
structures into a file, and load the data from that file the
next time the program runs. The JSON data format is not
specific to Python, so you can share this kind of data with
people who work in other languages as well.

try:
# Do something
except Exception as e:
print(e, type(e))

import json
filename = 'numbers.json'
with open(filename) as f_obj:
numbers = json.load(f_obj)
print(numbers)

Making sure the stored data exists
import json
f_name = 'numbers.json'
try:
with open(f_name) as f_obj:
numbers = json.load(f_obj)
except FileNotFoundError:
msg = "Can’t find {0}.".format(f_name)
print(msg)
else:
print(numbers)

Practice with exceptions
Take a program you've already written that prompts for user
input, and add some error-handling code to the program.

More cheat sheets available at

Building a testcase with one unit test

Running the test

To build a test case, make a class that inherits from
unittest.TestCase and write methods that begin with test_.
Save this as test_full_names.py

When you change your code, it’s important to run your existing
tests. This will tell you whether the changes you made affected
existing behavior.

import unittest
from full_names import get_full_name
class NamesTestCase(unittest.TestCase):
"""Tests for names.py."""

When you write a function or a class, you can also
write tests for that code. Testing proves that your
code works as it's supposed to in the situations it's
designed to handle, and also when people use your
programs in unexpected ways. Writing tests gives
you confidence that your code will work correctly as
more people begin to use your programs. You can
also add new features to your programs and know
that you haven't broken existing behavior.
A unit test verifies that one specific aspect of your
code works as it's supposed to. A test case is a
collection of unit tests which verify your code's
behavior in a wide variety of situations.

def test_first_last(self):
"""Test names like Janis Joplin."""
full_name = get_full_name('janis',
'joplin')
self.assertEqual(full_name,
'Janis Joplin')
unittest.main()

Running the test
Python reports on each unit test in the test case. The dot reports a
single passing test. Python informs us that it ran 1 test in less than
0.001 seconds, and the OK lets us know that all unit tests in the
test case passed.

.
--------------------------------------Ran 1 test in 0.000s
OK

Python's unittest module provides tools for testing your
code. To try it out, we’ll create a function that returns a full
name. We’ll use the function in a regular program, and then
build a test case for the function.

A function to test
Save this as full_names.py

def get_full_name(first, last):
"""Return a full name."""
full_name = "{0} {1}".format(first, last)
return full_name.title()

Using the function
Save this as names.py

from full_names import get_full_name
janis = get_full_name('janis', 'joplin')
print(janis)
bob = get_full_name('bob', 'dylan')
print(bob)

Failing tests are important; they tell you that a change in the
code has affected existing behavior. When a test fails, you
need to modify the code so the existing behavior still works.

Modifying the function
We’ll modify get_full_name() so it handles middle names, but
we’ll do it in a way that breaks existing behavior.

def get_full_name(first, middle, last):
"""Return a full name."""
full_name = "{0} {1} {2}".format(first,
middle, last)
return full_name.title()

E
================================================
ERROR: test_first_last (__main__.NamesTestCase)
Test names like Janis Joplin.
-----------------------------------------------Traceback (most recent call last):
File "test_full_names.py", line 10,
in test_first_last
'joplin')
TypeError: get_full_name() missing 1 required
positional argument: 'last'
-----------------------------------------------Ran 1 test in 0.001s
FAILED (errors=1)

Fixing the code
When a test fails, the code needs to be modified until the test
passes again. (Don’t make the mistake of rewriting your tests to fit
your new code.) Here we can make the middle name optional.

def get_full_name(first, last, middle=''):
"""Return a full name."""
if middle:
full_name = "{0} {1} {2}".format(first,
middle, last)
else:
full_name = "{0} {1}".format(first,
last)
return full_name.title()

Running the test
Now the test should pass again, which means our original
functionality is still intact.

.
--------------------------------------Ran 1 test in 0.000s
OK

Using the function
from full_names import get_full_name
john = get_full_name('john', 'lee', 'hooker')
print(john)
david = get_full_name('david', 'lee', 'roth')
print(david)

Covers Python 3 and Python 2

You can add as many unit tests to a test case as you need.
To write a new test, add a new method to your test case
class.

Testing a class is similar to testing a function, since you’ll
mostly be testing your methods.

Testing middle names

Save as accountant.py

We’ve shown that get_full_name() works for first and last
names. Let’s test that it works for middle names as well.

A class to test
class Accountant():
"""Manage a bank account."""

import unittest
from full_names import get_full_name

def __init__(self, balance=0):
self.balance = balance

class NamesTestCase(unittest.TestCase):
"""Tests for names.py."""
def test_first_last(self):
"""Test names like Janis Joplin."""
full_name = get_full_name('janis',
'joplin')
self.assertEqual(full_name,
'Janis Joplin')
def test_middle(self):
"""Test names like David Lee Roth."""
full_name = get_full_name('david',
'roth', 'lee')
self.assertEqual(full_name,
'David Lee Roth')

def deposit(self, amount):
self.balance += amount

Using setUp() to support multiple tests
The instance self.acc can be used in each new test.

import unittest
from accountant import Accountant
class TestAccountant(unittest.TestCase):
"""Tests for the class Accountant."""
def setUp(self):
self.acc = Accountant()

def withdraw(self, amount):
self.balance -= amount

def test_initial_balance(self):
# Default balance should be 0.
self.assertEqual(self.acc.balance, 0)

Building a testcase
For the first test, we’ll make sure we can start out with different
initial balances. Save this as test_accountant.py.

import unittest
from accountant import Accountant

# Test non-default balance.
acc = Accountant(100)
self.assertEqual(acc.balance, 100)

class TestAccountant(unittest.TestCase):
"""Tests for the class Accountant."""

def test_deposit(self):
# Test single deposit.
self.acc.deposit(100)
self.assertEqual(self.acc.balance, 100)

def test_initial_balance(self):
# Default balance should be 0.
acc = Accountant()
self.assertEqual(acc.balance, 0)

unittest.main()

Running the tests
The two dots represent two passing tests.

# Test multiple deposits.
self.acc.deposit(100)
self.acc.deposit(100)
self.assertEqual(self.acc.balance, 300)

# Test non-default balance.
acc = Accountant(100)
self.assertEqual(acc.balance, 100)

..
--------------------------------------Ran 2 tests in 0.000s
OK

When testing a class, you usually have to make an instance
of the class. The setUp() method is run before every test.
Any instances you make in setUp() are available in every
test you write.

def test_withdrawal(self):
# Test single withdrawal.
self.acc.deposit(1000)
self.acc.withdraw(100)
self.assertEqual(self.acc.balance, 900)

unittest.main()

Running the test
Python provides a number of assert methods you can use
to test your code.

.
--------------------------------------Ran 1 test in 0.000s

Verify that a==b, or a != b
assertEqual(a, b)
assertNotEqual(a, b)

Verify that x is True, or x is False
assertTrue(x)
assertFalse(x)

Verify an item is in a list, or not in a list
assertIn(item, list)
assertNotIn(item, list)

OK

In general you shouldn’t modify a test once it’s written.
When a test fails it usually means new code you’ve written
has broken existing functionality, and you need to modify
the new code until all existing tests pass.
If your original requirements have changed, it may be
appropriate to modify some tests. This usually happens in
the early stages of a project when desired behavior is still
being sorted out.

unittest.main()

Running the tests
...
--------------------------------------Ran 3 tests in 0.001s
OK

More cheat sheets available at

The following code sets up an empty game window, and
starts an event loop and a loop that continually refreshes
the screen.

An empty game window
import sys
import pygame as pg

Pygame is a framework for making games using
Python. Making games is fun, and it’s a great way to
expand your programming skills and knowledge.
Pygame takes care of many of the lower-level tasks
in building games, which lets you focus on the
aspects of your game that make it interesting.

Pygame runs on all systems, but setup is slightly different
on each OS. The instructions here assume you’re using
Python 3, and provide a minimal installation of Pygame. If
these instructions don’t work for your system, see the more
detailed notes at http://ehmatthes.github.io/pcc/.

Pygame on Linux
$ sudo apt-get install python3-dev mercurial
libsdl-image1.2-dev libsdl2-dev
libsdl-ttf2.0-dev
$ pip install --user
hg+http://bitbucket.org/pygame/pygame

Pygame on OS X
This assumes you’ve used Homebrew to install Python 3.

$ brew install hg sdl sdl_image sdl_ttf
$ pip install --user
hg+http://bitbucket.org/pygame/pygame

Pygame on Windows
Find an installer at
https://bitbucket.org/pygame/pygame/downloads/ or
http://www.lfd.uci.edu/~gohlke/pythonlibs/#pygame that matches
your version of Python. Run the installer file if it’s a .exe or .msi file.
If it’s a .whl file, use pip to install Pygame:

> python –m pip install --user
pygame-1.9.2a0-cp35-none-win32.whl

Testing your installation
To test your installation, open a terminal session and try to import
Pygame. If you don’t get any error messages, your installation was
successful.

$ python
>>> import pygame
>>>

def run_game():
# Initialize and set up screen.
pg.init()
screen = pg.display.set_mode((1200, 800))
pg.display.set_caption("Alien Invasion")
# Start main loop.
while True:
# Start event loop.
for event in pg.event.get():
if event.type == pg.QUIT:
sys.exit()
# Refresh screen.
pg.display.flip()
run_game()

Useful rect attributes
Once you have a rect object, there are a number of attributes that
are useful when positioning objects and detecting relative positions
of objects. (You can find more attributes in the Pygame
documentation.)

# Individual x and y values:
screen_rect.left, screen_rect.right
screen_rect.top, screen_rect.bottom
screen_rect.centerx, screen_rect.centery
screen_rect.width, screen_rect.height
# Tuples
screen_rect.center
screen_rect.size

Creating a rect object
You can create a rect object from scratch. For example a small rect
object that’s filled in can represent a bullet in a game. The Rect()
class takes the coordinates of the upper left corner, and the width
and height of the rect. The draw.rect() function takes a screen
object, a color, and a rect. This function fills the given rect with the
given color.

bullet_rect = pg.Rect(100, 100, 3, 15)
color = (100, 100, 100)
pg.draw.rect(screen, color, bullet_rect)

Setting a custom window size
The display.set_mode() function accepts a tuple that defines the
screen size.

screen_dim = (1200, 800)
screen = pg.display.set_mode(screen_dim)

Setting a custom background color
Colors are defined as a tuple of red, green, and blue values. Each
value ranges from 0-255.

bg_color = (230, 230, 230)
screen.fill(bg_color)

Many objects in a game are images that are moved around
the screen. It’s easiest to use bitmap (.bmp) image files, but
you can also configure your system to work with jpg, png,
and gif files as well.

Loading an image
ship = pg.image.load('images/ship.bmp')

Getting the rect object from an image
ship_rect = ship.get_rect()

Positioning an image
Many objects in a game can be treated as simple
rectangles, rather than their actual shape. This simplifies
code without noticeably affecting game play. Pygame has a
rect object that makes it easy to work with game objects.

With rects, it’s easy to position an image wherever you want on the
screen, or in relation to another object. The following code
positions a ship object at the bottom center of the screen.

ship_rect.midbottom = screen_rect.midbottom

Getting the screen rect object
We already have a screen object; we can easily access the rect
object associated with the screen.

screen_rect = screen.get_rect()

Finding the center of the screen
Rect objects have a center attribute which stores the center point.

screen_center = screen_rect.center

Covers Python 3 and Python 2

Drawing an image to the screen
Once an image is loaded and positioned, you can draw it to the
screen with the blit() method. The blit() method acts on the screen
object, and takes the image object and image rect as arguments.

# Draw ship to screen.
screen.blit(ship, ship_rect)

The blitme() method
Game objects such as ships are often written as classes. Then a
blitme() method is usually defined, which draws the object to the
screen.

def blitme(self):
"""Draw ship at current location."""
self.screen.blit(self.image, self.rect)

Pygame watches for events such as key presses and
mouse actions. You can detect any event you care about in
the event loop, and respond with any action that’s
appropriate for your game.

Pygame’s event loop registers an event any time the
mouse moves, or a mouse button is pressed or released.

Responding to the mouse button
for event in pg.event.get():
if event.type == pg.MOUSEBUTTONDOWN:
ship.fire_bullet()

Finding the mouse position
The mouse position is returned as a tuple.

mouse_pos = pg.mouse.get_pos()

Clicking a button
You might want to know if the cursor is over an object such as a
button. The rect.collidepoint() method returns true when a point is
inside a rect object.

if button_rect.collidepoint(mouse_pos):
start_game()

Hiding the mouse
pg.mouse.set_visible(False)

Responding to key presses
Pygame’s main event loop registers a KEYDOWN event any time a
key is pressed. When this happens, you can check for specific
keys.

for event in pg.event.get():
if event.type == pg.KEYDOWN:
if event.key == pg.K_RIGHT:
ship_rect.x += 1
elif event.key == pg.K_LEFT:
ship_rect.x -= 1
elif event.key == pg.K_SPACE:
ship.fire_bullet()
elif event.key == pg.K_q:
sys.exit()

Responding to released keys
When the user releases a key, a KEYUP event is triggered.

if event.type == pg.KEYUP:
if event.key == pg.K_RIGHT:
ship.moving_right = False

It’s important to delete elements that will never appear again in the
game, so you don’t waste memory and resources.

bullets.remove(bullet)

You can detect when a single object collides with any
member of a group. You can also detect when any member
of one group collides with a member of another group.

Collisions between a single object and a group
The spritecollideany() function takes an object and a group, and
returns True if the object overlaps with any member of the group.

if pg.sprite.spritecollideany(ship, aliens):
ships_left -= 1

Collisions between two groups
The sprite.groupcollide() function takes two groups, and two
booleans. The function returns a dictionary containing information
about the members that have collided. The booleans tell Pygame
whether to delete the members of either group that have collided.

collisions = pg.sprite.groupcollide(
bullets, aliens, True, True)
Pygame has a Group class which makes working with a
group of similar objects easier. A group is like a list, with
some extra functionality that’s helpful when building games.

score += len(collisions) * alien_point_value

Making and filling a group
An object that will be placed in a group must inherit from Sprite.

from pygame.sprite import Sprite, Group
def Bullet(Sprite):
...
def draw_bullet(self):
...
def update(self):
...
bullets = Group()
new_bullet = Bullet()
bullets.add(new_bullet)

Looping through the items in a group
The Pygame documentation is really helpful when building
your own games. The home page for the Pygame project is
at http://pygame.org/, and the home page for the
documentation is at http://pygame.org/docs/.
The most useful part of the documentation are the pages
about specific parts of Pygame, such as the Rect() class
and the sprite module. You can find a list of these elements
at the top of the help pages.

Removing an item from a group

The sprites() method returns all the members of a group.

for bullet in bullets.sprites():
bullet.draw_bullet()

Calling update() on a group
Calling update() on a group automatically calls update() on each
member of the group.

bullets.update()

You can use text for a variety of purposes in a game. For
example you can share information with players, and you
can display a score.

Displaying a message
The following code defines a message, then a color for the text and
the background color for the message. A font is defined using the
default system font, with a font size of 48. The font.render()
function is used to create an image of the message, and we get the
rect object associated with the image. We then center the image
on the screen and display it.

msg = "Play again?"
msg_color = (100, 100, 100)
bg_color = (230, 230, 230)
f = pg.font.SysFont(None, 48)
msg_image = f.render(msg, True, msg_color,
bg_color)
msg_image_rect = msg_image.get_rect()
msg_image_rect.center = screen_rect.center
screen.blit(msg_image, msg_image_rect)

More cheat sheets available at

Making a scatter plot

Emphasizing points

The scatter() function takes a list of x values and a list of y values,
and a variety of optional arguments. The s=10 argument controls
the size of each point.

You can plot as much data as you want on one plot. Here we replot the first and last points larger to emphasize them.

import matplotlib.pyplot as plt

import matplotlib.pyplot as plt
x_values = list(range(1000))
squares = [x**2 for x in x_values]

Data visualization involves exploring data through
visual representations. The matplotlib package helps
you make visually appealing representations of the
data you’re working with. matplotlib is extremely
flexible; these examples will help you get started with
a few simple visualizations.

plt.scatter(x_values, squares, s=10)
plt.show()

Plots can be customized in a wide variety of ways. Just
about any element of a plot can be customized.

Adding titles and labels, and scaling axes
import matplotlib.pyplot as plt

x_values = list(range(1000))
squares = [x**2 for x in x_values]
plt.scatter(x_values, squares, c=squares,
cmap=plt.cm.Blues, edgecolor='none',
s=10)
plt.scatter(x_values[0], squares[0], c='green',
edgecolor='none', s=100)
plt.scatter(x_values[-1], squares[-1], c='red',
edgecolor='none', s=100)
plt.title("Square Numbers", fontsize=24)
--snip--

Removing axes
matplotlib runs on all systems, but setup is slightly different
depending on your OS. If the minimal instructions here
don’t work for you, see the more detailed instructions at
http://ehmatthes.github.io/pcc/. You should also consider
installing the Anaconda distrubution of Python from
https://continuum.io/downloads/, which includes matplotlib.

matplotlib on Linux
$ sudo apt-get install python3-matplotlib

matplotlib on OS X
Start a terminal session and enter import matplotlib to see if
it’s already installed on your system. If not, try this command:

$ pip install --user matplotlib

matplotlib on Windows
You first need to install Visual Studio, which you can do from
https://dev.windows.com/. The Community edition is free. Then go
to https://pypi.python.org/pypi/matplotlib/ or
http://www.lfd.uic.edu/~gohlke/pythonlibs/#matplotlib and download
an appropriate installer file.

x_values = list(range(1000))
squares = [x**2 for x in x_values]
plt.scatter(x_values, squares, s=10)
plt.title("Square Numbers", fontsize=24)
plt.xlabel("Value", fontsize=18)
plt.ylabel("Square of Value", fontsize=18)
plt.tick_params(axis='both', which='major',
labelsize=14)
plt.axis([0, 1100, 0, 1100000])

You can customize or remove axes entirely. Here’s how to access
each axis, and hide it.

plt.axes().get_xaxis().set_visible(False)
plt.axes().get_yaxis().set_visible(False)

Setting a custom figure size
You can make your plot as big or small as you want. Before
plotting your data, add the following code. The dpi argument is
optional; if you don’t know your system’s resolution you can omit
the argument and adjust the figsize argument accordingly.

plt.figure(dpi=128, figsize=(10, 6))
plt.show()

Using a colormap
A colormap varies the point colors from one shade to another,
based on a certain value for each point. The value used to
determine the color of each point is passed to the c argument, and
the cmap argument specifies which colormap to use.
The edgecolor='none' argument removes the black outline
from each point.

plt.scatter(x_values, squares, c=squares,
cmap=plt.cm.Blues, edgecolor='none',
s=10)

Saving a plot
The matplotlib viewer has an interactive save button, but you can
also save your visualizations programmatically. To do so, replace
plt.show() with plt.savefig(). The bbox_inches='tight'
argument trims extra whitespace from the plot.

plt.savefig('squares.png', bbox_inches='tight')

The matplotlib gallery and documentation are at
http://matplotlib.org/. Be sure to visit the examples, gallery,
and pyplot links.

Making a line graph
import matplotlib.pyplot as plt
x_values = [0, 1, 2, 3, 4, 5]
squares = [0, 1, 4, 9, 16, 25]
plt.plot(x_values, squares)
plt.show()

Covers Python 3 and Python 2

You can make as many plots as you want on one figure.
When you make multiple plots, you can emphasize
relationships in the data. For example you can fill the space
between two sets of data.

Plotting two sets of data
Here we use plt.scatter() twice to plot square numbers and
cubes on the same figure.

import matplotlib.pyplot as plt
x_values = list(range(11))
squares = [x**2 for x in x_values]
cubes = [x**3 for x in x_values]
plt.scatter(x_values, squares, c='blue',
edgecolor='none', s=20)
plt.scatter(x_values, cubes, c='red',
edgecolor='none', s=20)
plt.axis([0, 11, 0, 1100])
plt.show()

Filling the space between data sets
The fill_between() method fills the space between two data
sets. It takes a series of x-values and two series of y-values. It also
takes a facecolor to use for the fill, and an optional alpha
argument that controls the color’s transparency.

plt.fill_between(x_values, cubes, squares,
facecolor='blue', alpha=0.25)

Many interesting data sets have a date or time as the xvalue. Python’s datetime module helps you work with this
kind of data.

Generating the current date
The datetime.now() function returns a datetime object
representing the current date and time.

from datetime import datetime as dt
today = dt.now()
date_string = dt.strftime(today, '%m/%d/%Y')
print(date_string)

Generating a specific date
You can also generate a datetime object for any date and time you
want. The positional order of arguments is year, month, and day.
The hour, minute, second, and microsecond arguments are
optional.

from datetime import datetime as dt
new_years = dt(2017, 1, 1)
fall_equinox = dt(year=2016, month=9, day=22)

Datetime formatting arguments
The strftime() function generates a formatted string from a
datetime object, and the strptime() function genereates a
datetime object from a string. The following codes let you work with
dates exactly as you need to.

%A
%B
%m
%d
%Y
%y
%H
%I
%p
%M
%S

Weekday name, such as Monday
Month name, such as January
Month, as a number (01 to 12)
Day of the month, as a number (01 to 31)
Four-digit year, such as 2016
Two-digit year, such as 16
Hour, in 24-hour format (00 to 23)
Hour, in 12-hour format (01 to 12)
AM or PM
Minutes (00 to 59)
Seconds (00 to 61)

You can include as many individual graphs in one figure as
you want. This is useful, for example, when comparing
related datasets.

Sharing an x-axis
The following code plots a set of squares and a set of cubes on
two separate graphs that share a common x-axis.
The plt.subplots() function returns a figure object and a tuple
of axes. Each set of axes corresponds to a separate plot in the
figure. The first two arguments control the number of rows and
columns generated in the figure.

import matplotlib.pyplot as plt
x_vals = list(range(11))
squares = [x**2 for x in x_vals]
cubes = [x**3 for x in x_vals]
fig, axarr = plt.subplots(2, 1, sharex=True)

Converting a string to a datetime object
new_years = dt.strptime('1/1/2017', '%m/%d/%Y')

axarr[0].scatter(x_vals, squares)
axarr[0].set_title('Squares')

Converting a datetime object to a string
ny_string = dt.strftime(new_years, '%B %d, %Y')
print(ny_string)

Plotting high temperatures
The following code creates a list of dates and a corresponding list
of high temperatures. It then plots the high temperatures, with the
date labels displayed in a specific format.

axarr[1].scatter(x_vals, cubes, c='red')
axarr[1].set_title('Cubes')
plt.show()

Sharing a y-axis
To share a y-axis, we use the sharey=True argument.

from datetime import datetime as dt

import matplotlib.pyplot as plt

import matplotlib.pyplot as plt
from matplotlib import dates as mdates

x_vals = list(range(11))
squares = [x**2 for x in x_vals]
cubes = [x**3 for x in x_vals]

dates = [
dt(2016, 6, 21), dt(2016, 6, 22),
dt(2016, 6, 23), dt(2016, 6, 24),
]
highs = [57, 68, 64, 59]
fig = plt.figure(dpi=128, figsize=(10,6))
plt.plot(dates, highs, c='red')
plt.title("Daily High Temps", fontsize=24)
plt.ylabel("Temp (F)", fontsize=16)
x_axis = plt.axes().get_xaxis()
x_axis.set_major_formatter(
mdates.DateFormatter('%B %d %Y')
)
fig.autofmt_xdate()
plt.show()

fig, axarr = plt.subplots(1, 2, sharey=True)
axarr[0].scatter(x_vals, squares)
axarr[0].set_title('Squares')
axarr[1].scatter(x_vals, cubes, c='red')
axarr[1].set_title('Cubes')
plt.show()

More cheat sheets available at

Making a scatter plot
The data for a scatter plot needs to be a list containing tuples of
the form (x, y). The stroke=False argument tells Pygal to make
an XY chart with no line connecting the points.

import pygal

Data visualization involves exploring data through
visual representations. Pygal helps you make visually
appealing representations of the data you’re working
with. Pygal is particularly well suited for visualizations
that will be presented online, because it supports
interactive elements.

squares = [
(0, 0), (1, 1), (2, 4), (3, 9),
(4, 16), (5, 25),
]
chart = pygal.XY(stroke=False)
chart.force_uri_protocol = 'http'
chart.add('x^2', squares)
chart.render_to_file('squares.svg')

Using a list comprehension for a scatter plot
Pygal can be installed using pip.

Pygal on Linux and OS X
$ pip install --user pygal

Pygal on Windows
> python –m pip install --user pygal

To make a plot with Pygal, you specify the kind of plot and
then add the data.

Making a line graph
To view the output, open the file squares.svg in a browser.

import pygal
x_values = [0, 1, 2, 3, 4, 5]
squares = [0, 1, 4, 9, 16, 25]
chart = pygal.Line()
chart.force_uri_protocol = 'http'
chart.add('x^2', squares)
chart.render_to_file('squares.svg')

Adding labels and a title
--snip-chart = pygal.Line()
chart.force_uri_protocol = 'http'
chart.title = "Squares"
chart.x_labels = x_values
chart.x_title = "Value"
chart.y_title = "Square of Value"
chart.add('x^2', squares)
chart.render_to_file('squares.svg')

A list comprehension can be used to effficiently make a dataset for
a scatter plot.

squares = [(x, x**2) for x in range(1000)]

Making a bar graph
A bar graph requires a list of values for the bar sizes. To label the
bars, pass a list of the same length to x_labels.

You can add as much data as you want when making a
visualization.

Plotting squares and cubes
import pygal
x_values = list(range(11))
squares = [x**2 for x in x_values]
cubes = [x**3 for x in x_values]
chart = pygal.Line()
chart.force_uri_protocol = 'http'
chart.title = "Squares and Cubes"
chart.x_labels = x_values
chart.add('Squares', squares)
chart.add('Cubes', cubes)
chart.render_to_file('squares_cubes.svg')

Filling the area under a data series
Pygal allows you to fill the area under or over each series of data.
The default is to fill from the x-axis up, but you can fill from any
horizontal line using the zero argument.

chart = pygal.Line(fill=True, zero=0)

import pygal
outcomes = [1, 2, 3, 4, 5, 6]
frequencies = [18, 16, 18, 17, 18, 13]
chart = pygal.Bar()
chart.force_uri_protocol = 'http'
chart.x_labels = outcomes
chart.add('D6', frequencies)
chart.render_to_file('rolling_dice.svg')

Making a bar graph from a dictionary
Since each bar needs a label and a value, a dictionary is a great
way to store the data for a bar graph. The keys are used as the
labels along the x-axis, and the values are used to determine the
height of each bar.

import pygal
results = {
1:18, 2:16, 3:18,
4:17, 5:18, 6:13,
}
chart = pygal.Bar()
chart.force_uri_protocol = 'http'
chart.x_labels = results.keys()
chart.add('D6', results.values())
chart.render_to_file('rolling_dice.svg')

The documentation for Pygal is available at
http://www.pygal.org/.

If you’re viewing svg output in a browser, Pygal needs to
render the output file in a specific way. The
force_uri_protocol attribute for chart objects needs to
be set to 'http'.

Covers Python 3 and Python 2

Pygal lets you customize many elements of a plot. There
are some excellent default themes, and many options for
styling individual plot elements.

Using built-in styles
To use built-in styles, import the style and make an instance of the
style class. Then pass the style object with the style argument
when you make the chart object.

import pygal
from pygal.style import LightGreenStyle
x_values = list(range(11))
squares = [x**2 for x in x_values]
cubes = [x**3 for x in x_values]
chart_style = LightGreenStyle()
chart = pygal.Line(style=chart_style)
chart.force_uri_protocol = 'http'
chart.title = "Squares and Cubes"
chart.x_labels = x_values
chart.add('Squares', squares)
chart.add('Cubes', cubes)
chart.render_to_file('squares_cubes.svg')

Parametric built-in styles
Some built-in styles accept a custom color, then generate a theme
based on that color.

from pygal.style import LightenStyle
--snip-chart_style = LightenStyle('#336688')
chart = pygal.Line(style=chart_style)
--snip--

Customizing individual style properties
Style objects have a number of properties you can set individually.

chart_style = LightenStyle('#336688')
chart_style.plot_background = '#CCCCCC'
chart_style.major_label_font_size = 20
chart_style.label_font_size = 16
--snip--

Custom style class
You can start with a bare style class, and then set only the
properties you care about.

chart_style = Style()
chart_style.colors = [
'#CCCCCC', '#AAAAAA', '#888888']
chart_style.plot_background = '#EEEEEE'
chart = pygal.Line(style=chart_style)
--snip--

Configuration settings
Some settings are controlled by a Config object.

my_config = pygal.Config()
my_config.show_y_guides = False
my_config.width = 1000
my_config.dots_size = 5
chart = pygal.Line(config=my_config)
--snip--

Styling series
You can give each series on a chart different style settings.

chart.add('Squares', squares, dots_size=2)
chart.add('Cubes', cubes, dots_size=3)

Styling individual data points
You can style individual data points as well. To do so, write a
dictionary for each data point you want to customize. A 'value'
key is required, and other properies are optional.

import pygal
repos = [
{
'value': 20506,
'color': '#3333CC',
'xlink': 'http://djangoproject.com/',
},
20054,
12607,
11827,
]
chart = pygal.Bar()
chart.force_uri_protocol = 'http'
chart.x_labels = [
'django', 'requests', 'scikit-learn',
'tornado',
]
chart.y_title = 'Stars'
chart.add('Python Repos', repos)
chart.render_to_file('python_repos.svg')

Pygal can generate world maps, and you can add any data
you want to these maps. Data is indicated by coloring, by
labels, and by tooltips that show data when users hover
over each country on the map.

Installing the world map module
The world map module is not included by default in Pygal 2.0. It
can be installed with pip:

$ pip install --user pygal_maps_world

Making a world map
The following code makes a simple world map showing the
countries of North America.

from pygal.maps.world import World
wm = World()
wm.force_uri_protocol = 'http'
wm.title = 'North America'
wm.add('North America', ['ca', 'mx', 'us'])
wm.render_to_file('north_america.svg')

Showing all the country codes
In order to make maps, you need to know Pygal’s country codes.
The following example will print an alphabetical list of each country
and its code.

from pygal.maps.world import COUNTRIES
for code in sorted(COUNTRIES.keys()):
print(code, COUNTRIES[code])

Plotting numerical data on a world map
To plot numerical data on a map, pass a dictionary to add()
instead of a list.

from pygal.maps.world import World
populations = {
'ca': 34126000,
'us': 309349000,
'mx': 113423000,
}
wm = World()
wm.force_uri_protocol = 'http'
wm.title = 'Population of North America'
wm.add('North America', populations)
wm.render_to_file('na_populations.svg')

More cheat sheets available at

The data in a Django project is structured as a set of
models.

Defining a model
To define the models for your app, modify the file models.py that
was created in your app’s folder. The __str__() method tells
Django how to represent data objects based on this model.

from django.db import models

Django is a web framework which helps you build
interactive websites using Python. With Django you
define the kind of data your site needs to work with,
and you define the ways your users can work with
that data.

It’s usualy best to install Django to a virtual environment,
where your project can be isolated from your other Python
projects. Most commands assume you’re working in an
active virtual environment.

Create a virtual environment
$ python –m venv ll_env

Activate the environment (Linux and OS X)
$ source ll_env/bin/activate

Activate the environment (Windows)
> ll_env\Scripts\activate

Install Django to the active environment
(ll_env)$ pip install Django

class Topic(models.Model):
"""A topic the user is learning about."""
text = models.CharField(max_length=200)
date_added = models.DateTimeField(
auto_now_add=True)
def __str__(self):
return self.text

Activating a model
To use a model the app must be added to the tuple
INSTALLED_APPS, which is stored in the project’s settings.py file.

INSTALLED_APPS = (
--snip-'django.contrib.staticfiles',
# My apps
'learning_logs',
)

Migrating the database
The database needs to be modified to store the kind of data that
the model represents.

$ python manage.py makemigrations learning_logs
$ python manage.py migrate

Creating a superuser
To start a project we’ll create a new project, create a
database, and start a development server.

Create a new project
$ django-admin.py startproject learning_log .

Create a database
$ python manage.py migrate

View the project
After issuing this command, you can view the project at
http://localhost:8000/.

$ python manage.py runserver

Create a new app
A Django project is made up of one or more apps.

$ python manage.py startapp learning_logs

A superuser is a user account that has access to all aspects of the
project.

$ python manage.py createsuperuser

Users interact with a project through web pages, and a
project’s home page can start out as a simple page with no
data. A page usually needs a URL, a view, and a template.

Mapping a project’s URLs
The project’s main urls.py file tells Django where to find the urls.py
files associated with each app in the project.

from django.conf.urls import include, url
from django.contrib import admin
urlpatterns = [
url(r'^admin/', include(admin.site.urls)),
url(r'', include('learning_logs.urls',
namespace='learning_logs')),
]

Mapping an app’s URLs
An app’s urls.py file tells Django which view to use for each URL in
the app. You’ll need to make this file yourself, and save it in the
app’s folder.

from django.conf.urls import url
from . import views
urlpatterns = [
url(r'^$', views.index, name='index'),
]

Writing a simple view
A view takes information from a request and sends data to the
browser, often through a template. View functions are stored in an
app’s views.py file. This simple view function doesn’t pull in any
data, but it uses the template index.html to render the home page.

from django.shortcuts import render
def index(request):
"""The home page for Learning Log."""
return render(request,
'learning_logs/index.html')

Registering a model
You can register your models with Django’s admin site, which
makes it easier to work with the data in your project. To do this,
modify the app’s admin.py file. View the admin site at
http://localhost:8000/admin/.

from django.contrib import admin

The documentation for Django is available at
http://docs.djangoproject.com/. The Django documentation
is thorough and user-friendly, so check it out!

from learning_logs.models import Topic
admin.site.register(Topic)

Covers Python 3 and Python 2

Writing a simple template
A template sets up the structure for a page. It’s a mix of html and
template code, which is like Python but not as powerful. Make a
folder called templates inside the project folder. Inside the
templates folder make another folder with the same name as the
app. This is where the template files should be saved.

<p>Learning Log</p>
<p>Learning Log helps you keep track of your
learning, for any topic you're learning
about.</p>

Many elements of a web page are repeated on every page
in the site, or every page in a section of the site. By writing
one parent template for the site, and one for each section,
you can easily modify the look and feel of your entire site.

A new model can use an existing model. The ForeignKey
attribute establishes a connection between instances of the
two related models. Make sure to migrate the database
after adding a new model to your app.

Defining a model with a foreign key
class Entry(models.Model):
"""Learning log entries for a topic."""
topic = models.ForeignKey(Topic)
text = models.TextField()
date_added = models.DateTimeField(
auto_now_add=True)
def __str__(self):
return self.text[:50] + "..."

The parent template

Most pages in a project need to present data that’s specific
to the current user.

The parent template defines the elements common to a set of
pages, and defines blocks that will be filled by individual pages.

URL parameters

<p>
<a href="{% url 'learning_logs:index' %}">
Learning Log
</a>
</p>
{% block content %}{% endblock content %}

The child template
The child template uses the {% extends %} template tag to pull in
the structure of the parent template. It then defines the content for
any blocks defined in the parent template.

{% extends 'learning_logs/base.html' %}
{% block content %}
<p>
Learning Log helps you keep track
of your learning, for any topic you're
learning about.
</p>
{% endblock content %}

Python code is usually indented by four spaces. In
templates you’ll often see two spaces used for indentation,
because elements tend to be nested more deeply in
templates.

A URL often needs to accept a parameter telling it which data to
access from the database. The second URL pattern shown here
looks for the ID of a specific topic and stores it in the parameter
topic_id.

urlpatterns = [
url(r'^$', views.index, name='index'),
url(r'^topics/(?P<topic_id>\d+)/$',
views.topic, name='topic'),
]

Using data in a template
The data in the view function’s context dictionary is available
within the template. This data is accessed using template
variables, which are indicated by doubled curly braces.
The vertical line after a template variable indicates a filter. In this
case a filter called date formats date objects, and the filter
linebreaks renders paragraphs properly on a web page.

{% extends 'learning_logs/base.html' %}
{% block content %}
<p>Topic: {{ topic }}</p>
<p>Entries:</p>
<ul>
{% for entry in entries %}
<li>
<p>
{{ entry.date_added|date:'M d, Y H:i' }}
</p>
<p>
{{ entry.text|linebreaks }}
</p>
</li>
{% empty %}
<li>There are no entries yet.</li>
{% endfor %}
</ul>
{% endblock content %}

Using data in a view
The view uses a parameter from the URL to pull the correct data
from the database. In this example the view is sending a context
dictionary to the template, containing data that should be displayed
on the page.

def topic(request, topic_id):
"""Show a topic and all its entries."""
topic = Topics.objects.get(id=topic_id)
entries = topic.entry_set.order_by(
'-date_added')
context = {
'topic': topic,
'entries': entries,
}
return render(request,
'learning_logs/topic.html', context)

If you make a change to your project and the change
doesn’t seem to have any effect, try restarting the server:
$ python manage.py runserver

You can explore the data in your project from the command
line. This is helpful for developing queries and testing code
snippets.

Start a shell session
$ python manage.py shell

Access data from the project
>>> from learning_logs.models import Topic
>>> Topic.objects.all()
[<Topic: Chess>, <Topic: Rock Climbing>]
>>> topic = Topic.objects.get(id=1)
>>> topic.text
'Chess'

More cheat sheets available at

Defining the URLs

Showing the current login status

Users will need to be able to log in, log out, and register. Make a
new urls.py file in the users app folder. The login view is a default
view provided by Django.

You can modify the base.html template to show whether the user is
currently logged in, and to provide a link to the login and logout
pages. Django makes a user object available to every template,
and this template takes advantage of this object.
The user.is_authenticated tag allows you to serve specific
content to users depending on whether they have logged in or not.
The {{ user.username }} property allows you to greet users
who have logged in. Users who haven’t logged in see links to
register or log in.

from django.conf.urls import url
from django.contrib.auth.views import login
from . import views

Most web applications need to let users create
accounts. This lets users create and work with their
own data. Some of this data may be private, and
some may be public. Django’s forms allow users to
enter and modify their data.

User accounts are handled by a dedicated app called
users. Users need to be able to register, log in, and log
out. Django automates much of this work for you.

Making a users app
After making the app, be sure to add 'users' to INSTALLED_APPS
in the project’s settings.py file.

$ python manage.py startapp users

Including URLS for the users app
Add a line to the project’s urls.py file so the users app’s URLs are
included in the project.

urlpatterns = [
url(r'^admin/', include(admin.site.urls)),
url(r'^users/', include('users.urls',
namespace='users')),
url(r'', include('learning_logs.urls',
namespace='learning_logs')),
]

There are a number of ways to create forms and work with
them. You can use Django’s defaults, or completely
customize your forms. For a simple way to let users enter
data based on your models, use a ModelForm. This creates
a form that allows users to enter data that will populate the
fields on a model.
The register view on the back of this sheet shows a simple
approach to form processing. If the view doesn’t receive
data from a form, it responds with a blank form. If it
receives POST data from a form, it validates the data and
then saves it to the database.

urlpatterns = [
url(r'^login/$', login,
{'template_name': 'users/login.html'},
name='login'),
url(r'^logout/$', views.logout_view,
name='logout'),
url(r'^register/$', views.register,
name='register'),
]

The login template
The login view is provided by default, but you need to provide your
own login template. The template shown here displays a simple
login form, and provides basic error messages. Make a templates
folder in the users folder, and then make a users folder in the
templates folder. Save this file as login.html.
The tag {% csrf_token %} helps prevent a common type of
attack with forms. The {{ form.as_p }} element displays the
default login form in paragraph format. The <input> element
named next redirects the user to the home page after a successful
login.

{% extends "learning_logs/base.html" %}

<p>
<a href="{% url 'learning_logs:index' %}">
Learning Log
</a>
{% if user.is_authenticated %}
Hello, {{ user.username }}.
<a href="{% url 'users:logout' %}">
log out
</a>
{% else %}
<a href="{% url 'users:register' %}">
register
</a> <a href="{% url 'users:login' %}">
log in
</a>
{% endif %}
</p>
{% block content %}{% endblock content %}

The logout view
{% block content %}
{% if form.errors %}
<p>
Your username and password didn't match.
Please try again.
</p>
{% endif %}
<form method="post"
action="{% url 'users:login' %}">
{% csrf token %}
{{ form.as_p }}
<button name="submit">log in</button>
<input type="hidden" name="next"
value="{% url 'learning_logs:index' %}"/>
</form>
{% endblock content %}

The logout_view() function uses Django’s logout() function
and then redirects the user back to the home page. Since there is
no logout page, there is no logout template. Make sure to write this
code in the views.py file that’s stored in the users app folder.

from django.http import HttpResponseRedirect
from django.core.urlresolvers import reverse
from django.contrib.auth import logout
def logout_view(request):
"""Log the user out."""
logout(request)
return HttpResponseRedirect(
reverse('learning_logs:index'))

Covers Python 3 and Python 2

The register view

The register template

Restricting access to logged-in users

The register view needs to display a blank registration form when
the page is first requested, and then process completed
registration forms. A successful registration logs the user in and
redirects to the home page.

The register template displays the registration form in paragraph
formats.

Some pages are only relevant to registered users. The views for
these pages can be protected by the @login_required decorator.
Any view with this decorator will automatically redirect non-logged
in users to an appropriate page. Here’s an example views.py file.

from django.contrib.auth import login
from django.contrib.auth import authenticate
from django.contrib.auth.forms import \
UserCreationForm
def register(request):
"""Register a new user."""
if request.method != 'POST':
# Show blank registration form.
form = UserCreationForm()
else:
# Process completed form.
form = UserCreationForm(
data=request.POST)
if form.is_valid():
new_user = form.save()
# Log in, redirect to home page.
pw = request.POST['password1']
authenticated_user = authenticate(
username=new_user.username,
password=pw
)
login(request, authenticated_user)
return HttpResponseRedirect(
reverse('learning_logs:index'))
context = {'form': form}
return render(request,
'users/register.html', context)

The django-bootstrap3 app allows you to use the Bootstrap
library to make your project look visually appealing. The
app provides tags that you can use in your templates to
style individual elements on a page. Learn more at
http://django-bootstrap3.readthedocs.io/.

{% extends 'learning_logs/base.html' %}
{% block content %}
<form method='post'
action="{% url 'users:register' %}">
{% csrf_token %}
{{ form.as_p }}
<button name='submit'>register</button>
<input type='hidden' name='next'
value="{% url 'learning_logs:index' %}"/>
</form>
{% endblock content %}

Users will have data that belongs to them. Any model that should
be connected directly to a user needs a field connecting instances
of the model to a specific user.

Making a topic belong to a user
Only the highest-level data in a hierarchy needs to be directly
connected to a user. To do this import the User model, and add it
as a foreign key on the data model.
After modifying the model you’ll need to migrate the database.
You’ll need to choose a user ID to connect each existing instance
to.

@login_required
def topic(request, topic_id):
"""Show a topic and all its entries."""

Setting the redirect URL
The @login_required decorator sends unauthorized users to the
login page. Add the following line to your project’s settings.py file
so Django will know how to find your login page.

LOGIN_URL = '/users/login/'

Preventing inadvertent access
Some pages serve data based on a parameter in the URL. You
can check that the current user owns the requested data, and
return a 404 error if they don’t. Here’s an example view.

from django.http import Http404
--snip-def topic(request, topic_id):
"""Show a topic and all its entries."""
topic = Topics.objects.get(id=topic_id)
if topic.owner != request.user:
raise Http404
--snip--

from django.db import models
from django.contrib.auth.models import User
class Topic(models.Model):
"""A topic the user is learning about."""
text = models.CharField(max_length=200)
date_added = models.DateTimeField(
auto_now_add=True)
owner = models.ForeignKey(User)
def __str__(self):
return self.text

Heroku lets you push your project to a live server, making it
available to anyone with an internet connection. Heroku
offers a free service level, which lets you learn the
deployment process without any commitment. You’ll need
to install a set of heroku tools, and use git to track the state
of your project. See http://devcenter.heroku.com/, and click
on the Python link.

from django.contrib.auth.decorators import /
login_required
--snip--

Querying data for the current user
In a view, the request object has a user attribute. You can use this
attribute to query for the user’s data. The filter() function then
pulls the data that belongs to the current user.

topics = Topic.objects.filter(
owner=request.user)

If you provide some initial data, Django generates a form
with the user’s existing data. Users can then modify and
save their data.

Creating a form with initial data
The instance parameter allows you to specify initial data for a form.

form = EntryForm(instance=entry)

Modifying data before saving
The argument commit=False allows you to make changes before
writing data to the database.

new_topic = form.save(commit=False)
new_topic.owner = request.user
new_topic.save()

More cheat sheets available at


